grammar org.osate.xtext.aadl2.errormodel.ErrorModel with org.eclipse.xtext.common.Terminals
//org.osate.xtext.aadl2.properties.Properties

generate errorModel "http://www.osate.org/aadl2/errormodel/ErrorModel"

//import 'platform:/resource/org.osate.xtext.aadl2/src-gen/org/osate/aadl2/Aadl2.ecore' as aadl2


//import "http://www.osate.org/aadl2/properties/Properties" as props

EM2AnnexSubclause :
    'annex'   EM   '{**'
	(types+=ErrorTypeSet  | ebsm+=ErrorBehaviorStateMachine 
	| ep+=ErrorPropagations | ceb+=ComponentErrorBehavior | compeb+=CompositeErrorBehavior)+
	'**}'
	SEMI ;
	
  
ErrorTypeSet returns ErrorTypeSet: 
    'errors' name=ID
    (types+=ErrorType)+ (features+=Feature)*
    'end' ID SEMI;

ErrorTypeSetRefinement returns ErrorTypeSet: 
    'errors' name=ID 'extends' extends=[ErrorTypeSet|ID] // [ErrorTypeSet|QCREF] across packages
    (types+=ErrorType|refinements+=ErrorTypeRefinement)+
    'end' ID;

ErrorType returns ErrorType: 
    name=ID COLON 'error' 'type' 
      ( ASSIGN LPARENS subtypes+=[ErrorType|ID]  
          ( COMMA subtypes+=[ErrorType|ID] )*
      RPARENS )? 
      SEMI;
      
Feature: 'feature' name=ID SEMI ;

ErrorTypeRefinement: 
    name=[ErrorType|ID] COLON 'refined' 'to' 
      ( APPEND LPARENS subtypes+=[ErrorType|ID]  
          ( COMMA subtypes+=[ErrorType|ID] )*
      RPARENS )? SEMI;

ErrorPropagations : 
   'error' 'propagations'
   'use' importedNamespace=QualifiedNameWithWildCard SEMI//use=[ErrorTypeSet|ID] SEMI
   ( => 'propagations'
   (propagations+=ErrorPropagation)+ )?
   ( => 'flows'
   (flows+=ErrorFlow)+)? 
   'end' SEMI
   ;
   
ErrorPropagation:
  type=[ErrorType|ID] COLON (mask?='not')? (direction=PropagationDirection)?  
  'propagation' 'applies' 'to' 
  ( binding+=BindingKind | appliesto+=[Feature|ID])
  ( COMMA ( binding+=BindingKind | appliesto+=[Feature|ID]) )*
   SEMI;
  
enum PropagationDirection:  IN = 'in' |  OUT = 'out' ;

BindingKind : ('processor'|'memory'|'bus'|'device'|'system'|'bindings');

  ErrorFlow :
  ErrorSource | ErrorSink | ErrorPath; 

ErrorSource :
  'error' 'source' outgoing=ErrorPropagationReference SEMI;

ErrorSink :
  'error' 'sink' incoming=ErrorPropagationReference SEMI;

ErrorPath :
  'error' 'path' incoming=ErrorPropagationReference '->' outgoing=ErrorPropagationReference SEMI;

  
ErrorPropagationReference :
   ( binding=BindingKind | feature=[Feature|ID] | self?='self') LBRACKET errortype=[ErrorType|ID] RBRACKET;

ErrorBehaviorStateMachine: 
  'error' 'model' name=ID
  ( => 'extends' extends=[ErrorBehaviorStateMachine|ID] )?
  ( => 'use' importedNamespace=QualifiedNameWithWildCard SEMI)? //use=[ErrorTypeSet|ID] SEMI )?
  ( => 'events' (events+=ErrorBehaviorEvent )+ )?
  ( => 'states' (states+=ErrorBehaviorState )+ )?
  ( => 'transitions' (transitions+=ErrorBehaviorTransition )+ )?
  'end' ID SEMI;
  
ErrorBehaviorEvent : 
  ErrorEvent | RepairEvent ;
  
ErrorEvent :
    name=ID COLON 'error' 'event' SEMI; // add event condition and properties
    
RepairEvent :
    name=ID COLON 'repair' 'event' SEMI; //add repair initiator and properties

ErrorBehaviorState : 
    name=ID (intial?='initial')? 'state'
    ( LCURLY (properties+=PropertyAssociation )+ RCURLY )? SEMI ;

ErrorBehaviorTransition :
  TriggeredTransition | BranchTransition;

TriggeredTransition:
  name = ID COLON source=[ErrorBehaviorState|ID] 
  ( '->' | LTRANS events+=[ErrorBehaviorEvent|ID] ( COMMA events+=[ErrorBehaviorEvent|ID])* RTRANS) 
  destination=[ErrorBehaviorState|ID] SEMI;

BranchTransition : source=[ErrorBehaviorState|ID] '-(' value=BranchValue ')->' destination=[ErrorBehaviorState|ID] SEMI;

BranchValue : 
  REAL | 'others';
  
ComponentErrorBehavior : 
	'error' 'behavior' 
   'use' importedNamespace=QualifiedNameWithWildCard SEMI//[ErrorBehaviorStateMachine|ID] SEMI
   ( 'transition' 'conditions'
    ( transitionCondition+=TransitionCondition )+ )?
   ( 'propagation' 'conditions'
    ( propagationCondition+=PropagationCondition )+ )?
   ( 'detection' 'events'
    ( detectionEvent+=DetectionEvent )+ )?
   'end' SEMI
;  

QualifiedName:
  ID (DOT ID)*;
  
QualifiedNameWithWildCard:
  QualifiedName '.*'?;

TransitionCondition returns TransitionCondition: 
	( errorTransition=[TriggeredTransition|ID] | mask?='mask')
	'when' condition=TriggerConditionExpression SEMI
;

TriggerConditionExpression : 
	OrExpression
    | OrmoreExpression
    | OrlessExpression
	| OthersExpression 
;


AndExpression returns TriggerConditionExpression:
  Primary ({AndExpression.operands+=current} 'and' operands+=Primary)*;
  
OrExpression returns TriggerConditionExpression:
  AndExpression ( {OrExpression.operands+=current} 'or' operands+=AndExpression)*;
  
OrmoreExpression returns OrmoreExpression: 
	count=INT 'ormore' LPARENS operands+=TriggerConditionExpression
	            ( COMMA operands+=TriggerConditionExpression)* RPARENS
;
  
OrlessExpression returns OrlessExpression: 
	count=INT 'orless' LPARENS operands+=TriggerConditionExpression
	            ( COMMA operands+=TriggerConditionExpression)* RPARENS
;
  
OthersExpression returns OthersExpression: {OthersExpression}'others';
  
Primary returns TriggerConditionExpression:
  ErrorEventReference | ErrorPropagationReference | WorkingReference |
  LPARENS TriggerConditionExpression RPARENS;
 

ErrorEventReference returns ErrorEventReference:
	'event' reference=[ErrorBehaviorEvent|ID]
;

WorkingReference returns WorkingReference:
   ( binding=BindingKind | feature=[Feature|ID] | self?='self') 
	   LBRACKET ( working?='working') RBRACKET
;

PropagationCondition : 
	( outPropagation=[ErrorPropagation|ID] | mask?='mask' | working?='working')
	'when' (state=[ErrorBehaviorState|ID] 'and')? condition=TriggerConditionExpression 
	( => 'applies' 'to' feature+=[Feature|ID] (COMMA feature+=[Feature|ID])*)?SEMI
;

DetectionEvent : 
	(self?='self' DOT)? eventPort=[Feature|ID] 
	'when' condition=TriggerConditionExpression SEMI
;

CompositeErrorBehavior : 
	'composite' 'error' 'behavior' 
   'use' importedNamespace=QualifiedNameWithWildCard SEMI//[ErrorBehaviorStateMachine|ID] SEMI
   ( 'states' 
    ( state+=CompositeState )+ 
    )?
   'end' SEMI
; 

CompositeState returns CompositeState:
	state=[ErrorBehaviorState] 'when' condition=StateConditionExpression SEMI;

StateConditionExpression : 
	OrSExpression
    | OrmoreSExpression
    | OrlessSExpression
	| OthersExpression 
;


AndSExpression returns StateConditionExpression:
  Primary ({AndExpression.operands+=current} 'and' operands+=Primary)*;
  
OrSExpression returns StateConditionExpression:
  AndExpression ( {OrExpression.operands+=current} 'or' operands+=AndExpression)*;
  
OrmoreSExpression returns OrmoreExpression: 
	count=INT 'ormore' LPARENS operands+=StateConditionExpression
	            ( COMMA operands+=StateConditionExpression)* RPARENS
;
  
OrlessSExpression returns OrlessExpression: 
	count=INT 'orless' LPARENS operands+=StateConditionExpression
	            ( COMMA operands+=StateConditionExpression)* RPARENS
;
  
  
SPrimary returns StateConditionExpression:
  SubcomponentStateReference |
  LPARENS StateConditionExpression RPARENS;

SubcomponentStateReference :
   subcomponent=[Feature|ID] LBRACKET errortype=[ErrorBehaviorState|ID] RBRACKET;


PropertyAssociation:
	name=ID ASSIGN value=PropertyExpression SEMI;

PropertyExpression:
	Literal | ProbabilityValue;

Literal:
	name=ID;

ProbabilityValue:
	number=REAL distribution=ID;

terminal EM : 'error_model';

terminal NONE:
	'none' SEMI;

terminal LTRANS:
	'-[';

terminal RTRANS:
	']->';

terminal SL_COMMENT:
	'--' !('\n' | '\r')* ('\r'? '\n')?;

terminal SEMI:
	';';

terminal COLON:
	':';

terminal COMMA:
	',';

terminal DOT:
	'.';

terminal LPARENS:
	'(';

terminal RPARENS:
	')';

terminal LBRACKET:
	'[';

terminal RBRACKET:
	']';

terminal LCURLY:
	'{';

terminal RCURLY:
	'}';

terminal ASSIGN:
	'=>';

terminal APPEND:
	'+=>';

REAL: INT DOT INT;

QNAME:
	ID DOT INAME;

PNAME:
	ID ('::' ID)*;

INAME:
	ID;

QCREF:
	(ID '::')* ID (DOT ID)?;


