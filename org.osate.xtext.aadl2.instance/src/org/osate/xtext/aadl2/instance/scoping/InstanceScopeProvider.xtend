/*
 * generated by Xtext
 */
package org.osate.xtext.aadl2.instance.scoping

import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.resource.EObjectDescription
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.scoping.impl.SimpleScope
import org.osate.aadl2.Aadl2Package
import org.osate.aadl2.AadlPackage
import org.osate.aadl2.Classifier
import org.osate.aadl2.ComponentClassifier
import org.osate.aadl2.ComponentImplementation
import org.osate.aadl2.ComponentType
import org.osate.aadl2.FeatureGroupType
import org.osate.aadl2.NamedElement
import org.osate.aadl2.instance.ComponentInstance
import org.osate.aadl2.instance.ConnectionInstance
import org.osate.aadl2.instance.EndToEndFlowInstance
import org.osate.aadl2.instance.FeatureInstance
import org.osate.aadl2.instance.FlowSpecificationInstance
import org.osate.aadl2.instance.InstanceObject
import org.osate.aadl2.instance.ModeInstance
import org.osate.aadl2.instance.SystemInstance

import static extension org.eclipse.emf.ecore.util.EcoreUtil.resolve
import static extension org.eclipse.xtext.EcoreUtil2.eAllContentsAsList
import static extension org.eclipse.xtext.EcoreUtil2.getContainerOfType
import static extension org.eclipse.xtext.scoping.Scopes.scopeFor
import static extension org.eclipse.xtext.scoping.Scopes.scopedElementsFor

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class InstanceScopeProvider extends AbstractDeclarativeScopeProvider {
	val ResourceDescriptionsProvider rdp
	
	@Inject
	new(ResourceDescriptionsProvider rdp) {
		this.rdp = rdp
	}
	
	def IScope scope_FeatureInstance_feature(EObject context, EReference reference) {
		val fromComponents = <ComponentType>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentType, [ownedFeatures])
		val fromFeatureGroups = <FeatureGroupType>getDeclarativeScope(context, Aadl2Package.eINSTANCE.featureGroupType, [ownedFeatures])
		new SimpleScope(fromComponents + fromFeatureGroups)
	}
	
	def IScope scope_FlowSpecificationInstance(ComponentInstance context, EReference reference) {
		context.flowSpecifications.scopeFor
	}
	
	def IScope scope_ConnectionInstance(EObject context, EReference reference) {
		switch parent : context.eContainer.getContainerOfType(ComponentInstance) {
			case null: IScope.NULLSCOPE
			default: new SimpleScope(doConnection(0, parent))
		}
	}
	
	def IScope scope_ComponentInstance_inMode(ComponentInstance context, EReference reference) {
		val parent = context.eContainer.getContainerOfType(ComponentInstance)
		(parent?.modeInstances ?: emptyList).scopeFor
	}
	
	def IScope scope_ComponentInstance_subcomponent(EObject context, EReference reference) {
		new SimpleScope(<ComponentImplementation>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentImplementation, [ownedSubcomponents]))
	}
	
	def IScope scope_ConnectionInstanceEnd(ComponentInstance context, EReference reference) {
		new SimpleScope(context.getInstanceScope(FeatureInstance, ComponentInstance))
	}
	
	def IScope scope_SystemOperationMode(SystemInstance context, EReference reference) {
		new SimpleScope(context.systemOperationModes.indexed.map[EObjectDescription.create(key.toString, value)])
	}
	
	def IScope scope_ModeTransitionInstance(ComponentInstance context, EReference reference) {
		new SimpleScope(context.modeTransitionInstances.indexed.map[EObjectDescription.create(key.toString, value)])
	}
	
	def IScope scope_ConnectionReference_connection(EObject context, EReference reference) {
		new SimpleScope(<ComponentImplementation>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentImplementation, [ownedConnections]))
	}
	
	def IScope scope_ConnectionReference_context(ComponentInstance context, EReference reference) {
		new SimpleScope(#[EObjectDescription.create("parent", context)] + context.getInstanceScope(ComponentInstance))
	}
	
	def IScope scope_FeatureInstance(ComponentInstance context, EReference reference) {
		new SimpleScope(context.getInstanceScope(FeatureInstance))
	}
	
	def IScope scope_ModeInstance(ComponentInstance context, EReference reference) {
		context.modeInstances.scopeFor
	}
	
	def IScope scope_FlowSpecificationInstance_flowSpecification(EObject context, EReference reference) {
		new SimpleScope(<ComponentType>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentType, [ownedFlowSpecifications]))
	}
	
	def IScope scope_EndToEndFlowInstance_flowElement(ComponentInstance context, EReference reference) {
		new SimpleScope(context.getInstanceScope(ComponentInstance, ConnectionInstance, EndToEndFlowInstance, FlowSpecificationInstance))
	}
	
	def IScope scope_EndToEndFlowInstance_endToEndFlow(EObject context, EReference reference) {
		new SimpleScope(<ComponentImplementation>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentImplementation, [ownedEndToEndFlows]))
	}
	
	def IScope scope_ModeInstance_parent(ComponentInstance context, EReference reference) {
		val parent = context.eContainer.getContainerOfType(ComponentInstance)
		(parent?.modeInstances ?: emptyList).scopeFor
	}
	
	def IScope scope_ModeInstance_mode(EObject context, EReference reference) {
		new SimpleScope(<ComponentClassifier>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentClassifier, [ownedModes]))
	}
	
	def IScope scope_ModeTransitionInstance_modeTransition(EObject context, EReference reference) {
		new SimpleScope(<ComponentClassifier>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentClassifier, [ownedModeTransitions]))
	}
	
	def IScope scope_SystemOperationMode_currentMode(ComponentInstance context, EReference reference) {
		new SimpleScope(context.getInstanceScope(ModeInstance))
	}
	
	def private static Iterable<IEObjectDescription> doConnection(int levelCount, ComponentInstance component) {
		val descriptions = component.connectionInstances.indexed.map[
			EObjectDescription.create('''«IF levelCount > 0»«levelCount».«ENDIF»«key»''', value)
		]
		switch parent : component.eContainer {
			ComponentInstance: descriptions + doConnection(levelCount + 1, parent)
			default: descriptions
		}
	}
	
	def private <T extends Classifier> getDeclarativeScope(EObject context, EClass containerEClass, (T)=>List<? extends NamedElement> elementsGetter) {
		val rds = rdp.getResourceDescriptions(context.eResource)
		val classifierDescriptions = rds.getExportedObjectsByType(containerEClass)
		val classifiers = classifierDescriptions.map[EObjectOrProxy.resolve(context) as T]
		classifiers.map[classifier |
			val pkgName = classifier.getContainerOfType(AadlPackage).name
			elementsGetter.apply(classifier).map[element |
				val qualifiedName = QualifiedName.create(pkgName.split("::") + #[classifier.name, element.name])
				EObjectDescription.create(qualifiedName, element)
			]
		].flatten
	}
	
	def private getInstanceScope(ComponentInstance context, Class<?>... types) {
		context.eAllContentsAsList.filter[element | types.exists[isInstance(element)]].scopedElementsFor[QualifiedName.create(getInstanceScopeName(context))]
	}
	
	def private static String getInstanceScopeName(EObject element, ComponentInstance root) {
		val prefix = if (element.eContainer == root) {
			""
		} else {
			getInstanceScopeName(element.eContainer, root) + "."
		}
		prefix + switch element {
			ComponentInstance: '''«element.name»«FOR index : element.indices»[«index»]«ENDFOR»'''
			ConnectionInstance: element.getContainerOfType(ComponentInstance).connectionInstances.indexOf(element)
			FeatureInstance: '''«element.name»«IF element.index != 0»[«element.index»]«ENDIF»'''
			InstanceObject: element.name
		}
	}
}