grammar org.osate.xtext.aadl2.properties.Properties with org.eclipse.xtext.common.Terminals

//generate properties "http://www.osate.org/aadl2/properties/Properties"


import "platform:/resource/org.osate.aadl2/model/aadl2.ecore" as aadl2


PropertySet returns aadl2::PropertySet:
	'property' 'set' name=ID 'is'
	(=> 'with' (importedPropertySet+=[aadl2::PropertySet|ID]) //| importedPropertySet+=[props::PropertySet|ID]) 
	    (COMMA importedPropertySet+=[aadl2::PropertySet|ID])* SEMI)*
	(ownedPropertyType+=PropertyType | ownedProperty+=PropertyDefinition 
	| ownedPropertyConstant+=PropertyConstant)*
	'end' ID SEMI ;

PropertyType returns aadl2::PropertyType:
	(BooleanType|StringType|EnumerationType|UnitsType// |RealType
	|IntegerType|ClassifierType|ReferenceType|RecordType) 
	SEMI;

UnnamedPropertyType returns aadl2::PropertyType:
	(UnnamedBooleanType|UnnamedStringType|UnnamedEnumerationType|UnnamedUnitsType// |UnnamedRealType
	|UnnamedIntegerType|UnnamedClassifierType|UnnamedReferenceType|UnnamedRecordType) 
	;


BooleanType returns aadl2::AadlBoolean:
	name=ID COLON 'type' 
	{aadl2::AadlBoolean}'aadlboolean';


UnnamedBooleanType returns aadl2::AadlBoolean:
	{aadl2::AadlBoolean}'aadlboolean';

StringType returns aadl2::AadlString:
	name=ID COLON 'type' 
	{aadl2::AadlString}'aadlstring';

UnnamedStringType returns aadl2::AadlString:
	{aadl2::AadlString}'aadlstring';

EnumerationType returns aadl2::EnumerationType:
	name=ID COLON 'type' 
	'enumeration'
	LPARENS ownedLiteral+=EnumerationLiteral (COMMA ownedLiteral+=EnumerationLiteral)* RPARENS;

UnnamedEnumerationType returns aadl2::EnumerationType:
	'enumeration'
	LPARENS ownedLiteral+=EnumerationLiteral (COMMA ownedLiteral+=EnumerationLiteral)* RPARENS;

EnumerationLiteral returns aadl2::EnumerationLiteral:
	name=ID;

UnitsType returns aadl2::UnitsType:
	name=ID COLON 'type' 
	'units'
	LPARENS ownedLiteral+=UnitLiteral (COMMA ownedLiteral+=EnumerationLiteral)* RPARENS;

UnnamedUnitsType returns aadl2::UnitsType:
	'units'
	LPARENS ownedLiteral+=UnitLiteral (COMMA ownedLiteral+=EnumerationLiteral)* RPARENS;

UnitLiteral returns aadl2::UnitLiteral:
	name=ID;

UnitLiteralConversion returns aadl2::UnitLiteral:
	name=ID ASSIGN baseUnit=[aadl2::UnitLiteral|ID] STAR //factor=NumberValue
	;
//
//RealType returns aadl2::AadlReal:
//	name=ID COLON 'type' 
//	'aadlreal' (range+=RealRange)* ('units' (ownedUnitsType=UnitsType| UnitsType=[aadl2::UnitsType|ID]))*
//	 ;
//
//UnnamedRealType returns aadl2::AadlReal:
//	'aadlreal' (range+=RealRange)* ('units' (ownedUnitsType=UnitsType| UnitsType=[aadl2::UnitsType|ID]))*
//	 ;

IntegerType returns aadl2::AadlInteger:
	name=ID COLON 'type' 
	{aadl2::AadlInteger}
	'aadlinteger' //(IntegerRange)* ('units' (ownedUnitsType=UnitsType| UnitsType=[aadl2::UnitsType|ID]))*
	 ;

UnnamedIntegerType returns aadl2::AadlInteger:
	{aadl2::AadlInteger}
	'aadlinteger' //(IntegerRange)* ('units' (ownedUnitsType=UnitsType| UnitsType=[aadl2::UnitsType|ID]))*
	 ;

ClassifierType returns aadl2::ClassifierType:
	name=ID COLON 'type' 
	{aadl2::ClassifierType}
	'classifier' 
	(classifierReference+=QCReference (COMMA classifierReference+=QCReference)*)?
	 ;

UnnamedClassifierType returns aadl2::ClassifierType:
	{aadl2::ClassifierType}
	'classifier' 
	(classifierReference+=QCReference (COMMA classifierReference+=QCReference)*)?
	 ;

QCReference returns aadl2::MetaclassReference:
	(LCURLY STAR STAR annexName=ID STAR STAR RCURLY )?
	metaclassName+=ID
	 ;

ReferenceType returns aadl2::ReferenceType:
	name=ID COLON 'type' 
	'reference' 
	(namedElementReference+=QCReference (COMMA namedElementReference+=QCReference)*)?
	 ;

UnnamedReferenceType returns aadl2::ReferenceType:
	'reference' {aadl2::ReferenceType}
	(namedElementReference+=QCReference (COMMA namedElementReference+=QCReference)*)?
	 ;

RecordType returns aadl2::RecordType:
	name=ID COLON 'type' 
	'record' LPARENS
	(ownedField+=RecordField )+
	RPARENS
	 ;

UnnamedRecordType returns aadl2::RecordType:
	'record' LPARENS
	(ownedField+=RecordField )+
	RPARENS
	 ;

//&&&&&&& TODO list is currently a count
RecordField returns aadl2::RecordField:
	name=ID COLON
//	(list+='list' 'of')*
	(type=[aadl2::PropertyType|QPREF]|ownedType=UnnamedPropertyType)
	 ;

//&&&&& Property Definition


PropertyDefinition returns aadl2::Property:
	name=ID COLON
	(inherit?='inherit')?
//	(list+='list' 'of')*
	(type=[aadl2::PropertyType|QPREF]|ownedType=UnnamedPropertyType)
	// &&&& We set only owned or reference - not both
	(ASSIGN defaultValue=PropertyExpression)?
	'applies' 'to' LPARENS
	((appliesTo+=PropertyOwner (COMMA appliesTo+=PropertyOwner)*)|
	appliesTo+=AllReference)
	RPARENS
	SEMI
	 ;

AllReference returns aadl2::MetaclassReference:
	 metaclassName+='all'  // &&&&& actually set it to NamedElement using ALL rule returning "named element" as string
;

PropertyOwner returns aadl2::PropertyOwner:
	// both alternatives are identifiers
	(QCReference)//|ClassifierValue)
	 ;


ClassifierValue returns aadl2::ClassifierValue:
	classifier=[aadl2::ComponentClassifier|QCREF] ;

PropertyConstant returns aadl2::PropertyConstant:
	name=ID COLON 'constant'
//	(list+='list' 'of')*
	(type=[aadl2::PropertyType|QPREF]|ownedType=UnnamedPropertyType)
//	ASSIGN defaultValue=ConstantPropertyExpression  //&&& same as PropertyExpression??
	SEMI
	 ;




//NumberValue returns aadl2::NumberValue:
//	RealLit | IntegerLit ;
//
//RealLit returns aadl2::RealLiteral:
//	value+=REAL ;
//
//
//IntegerLit returns aadl2::IntegerLiteral:
//	value+=INT ;



PropertyAssociation returns aadl2::PropertyAssociation:
	// &&&&&&&&& have name as attribute. It gets resolved into a reference to a property definition
	property=[aadl2::Property|QPREF] // name=QPREF
	(ASSIGN | append?=APPEND) (constant?='constant')?
	(ownedValue+=PropertyValue 
	| (
	LPARENS ownedValue+=ModalPropertyValue 
	(COMMA ownedValue+=ModalPropertyValue)*
	(COMMA ownedValue+=PropertyValue)?
	RPARENS )
	)
	SEMI;

ModalPropertyValue returns aadl2::ModalPropertyValue:
	ownedValue=PropertyExpression 
	'in' 'modes' LPARENS 
	inMode+=[aadl2::Mode|ID] (COMMA inMode+=[aadl2::Mode|ID])*
	RPARENS
	;

PropertyValue returns aadl2::ModalPropertyValue:
	ownedValue=PropertyExpression 
	;

PropertyExpression returns aadl2::PropertyExpression:
	ComputedTerm | StringTerm | BooleanTerm| => ListTerm
	;

NoListPropertyExpression returns aadl2::PropertyExpression:
	ComputedTerm | StringTerm //| BooleanTerm
	;

BooleanTerm returns aadl2::PropertyExpression:
	OrTerm ;

  
OrTerm returns aadl2::PropertyExpression:
  AndTerm ( {aadl2::Operation.ownedPropertyExpression+=current} op=OrOp ownedPropertyExpression+=AndTerm)*;


AndTerm returns aadl2::PropertyExpression:
  BooleanAtom ({aadl2::Operation.ownedPropertyExpression+=current} op=AndOp ownedPropertyExpression+=BooleanAtom)*;


NotTerm returns aadl2::Operation:
  op=NotOp ownedPropertyExpression+=BooleanAtom;



BooleanAtom returns aadl2::PropertyExpression:
	( BooleanLiteral  | NotTerm | ConstantValue
	| (LPARENS BooleanTerm RPARENS)
	);

BooleanLiteral returns aadl2::BooleanLiteral:
  {aadl2::BooleanLiteral}(value?='true'|'false')
  //Assumes: default for value is false
  ;

ConstantValue returns aadl2::ConstantValue:
  constant=[aadl2::PropertyConstant|QPREF]
  ;

ReferenceTerm returns aadl2::ReferenceValue:
  'reference' LPARENS 	
  containmentPathElement+=ContainmentPathElement
	( DOT containmentPathElement+=ContainmentPathElement)*
  RPARENS
  ;

RecordTerm returns aadl2::RecordValue:
   LPARENS 	
   (ownedFieldValue+=BasicPropertyAssociation)+
  RPARENS
  ;

ComputedTerm returns aadl2::ComputedValue:
   'compute' LPARENS 	
   function=ID
  RPARENS
  ;

ComponentClassifierTerm returns aadl2::ClassifierValue:
   'classifier' LPARENS 	
   classifier=[aadl2::ComponentClassifier|QCREF]
  RPARENS
  ;


ListTerm returns aadl2::ListValue:
   LPARENS 	
   ownedListElement+=(PropertyExpression)
   (COMMA ownedListElement+=(PropertyExpression))*
  RPARENS
  ;

BasicPropertyAssociation returns aadl2::BasicPropertyAssociation:
	property=[aadl2::RecordField|ID] // name=QPREF
	ASSIGN 
	ownedValue=PropertyExpression 
	SEMI;

// from AADL2
// need to add annex path element
ContainmentPathElement returns aadl2::ContainmentPathElement:
	((namedElement=[aadl2::NamedElement|ID]
//	 (arrayRange+=ArrayRange)?
	 ) |
	 'annex' namedElement=[aadl2::NamedElement|ANNEXREF]
	)
;

ANNEXREF :
	// check what values are ok inside ** **
	LCURLY STAR STAR ID STAR STAR RCURLY;

  
// enum, unit, constant ref, property ref all may have just an ID
// NameResolver knows based on type


enum OperationKind returns aadl2::OperationKind:
	 and='and' | or='or' | not='not';
// Need Value Converters	
AndOp returns aadl2::OperationKind: 'and';
OrOp returns aadl2::OperationKind: 'or';
NotOp returns aadl2::OperationKind: 'not';


StringTerm returns aadl2::StringLiteral:
	value=NoQuoteString ;


NoQuoteString :
	// remove quotes from string in ValueConverter
	STRING
;


IntegerTerm returns aadl2::IntegerLiteral:
	value=SignedInt (unit=[aadl2::UnitLiteral|ID])?
	// or constant is not handled in O2 grammar
	// valueString not set
	;

SignedInt returns aadl2::Integer:
	// in O2 parser: minus sign handled strangely
	// Need valueconverter
	('+'|'-')?INT ;
	
// IntegerLiteral allowing underscore in teh middle of the digits

RealTerm returns aadl2::RealLiteral:
	value=SignedReal (unit=[aadl2::UnitLiteral|ID])?
	// or constant is not handled in O2 grammar
	// valueString not set
	;

SignedReal returns aadl2::Real:
	// in O2 parser: minus sign handled strangely
	// Need valueconverter
	('+'|'-')?REAL ;


terminal NONE:
	'none' SEMI;

terminal LTRANS:
	'-[';

terminal RTRANS:
	']->';

terminal SL_COMMENT:
	'--' !('\n' | '\r')* ('\r'? '\n')?;

terminal SEMI:
	';';

terminal COLON:
	':';

terminal COMMA:
	',';

terminal DOT:
	'.';

terminal LPARENS:
	'(';

terminal RPARENS:
	')';

terminal LBRACKET:
	'[';

terminal RBRACKET:
	']';

terminal LCURLY:
	'{';

terminal RCURLY:
	'}';

terminal ASSIGN:
	'=>';

terminal APPEND:
	'+=>';

REAL:
	INT DOT INT;

QNAME:
	ID DOT INAME;

PNAME:
	ID ('::' ID)*;

INAME:
	ID;

QPREF:
	ID ('::' ID)?;

QCREF:
	(ID '::')* ID (DOT ID)?;
	
STAR : '*';
