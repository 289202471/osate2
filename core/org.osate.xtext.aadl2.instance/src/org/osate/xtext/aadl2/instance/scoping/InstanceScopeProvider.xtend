/*
 * generated by Xtext
 */
package org.osate.xtext.aadl2.instance.scoping

import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.resource.EObjectDescription
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.scoping.impl.SimpleScope
import org.osate.aadl2.Aadl2Package
import org.osate.aadl2.AadlPackage
import org.osate.aadl2.BasicPropertyAssociation
import org.osate.aadl2.BehavioredImplementation
import org.osate.aadl2.Classifier
import org.osate.aadl2.ComponentClassifier
import org.osate.aadl2.ComponentImplementation
import org.osate.aadl2.ComponentType
import org.osate.aadl2.Element
import org.osate.aadl2.EnumerationType
import org.osate.aadl2.FeatureGroupType
import org.osate.aadl2.ModeTransition
import org.osate.aadl2.NamedElement
import org.osate.aadl2.NumberType
import org.osate.aadl2.PropertyAssociation
import org.osate.aadl2.PropertyType
import org.osate.aadl2.RangeType
import org.osate.aadl2.RecordType
import org.osate.aadl2.RecordValue
import org.osate.aadl2.instance.ComponentInstance
import org.osate.aadl2.instance.ConnectionInstance
import org.osate.aadl2.instance.EndToEndFlowInstance
import org.osate.aadl2.instance.FeatureInstance
import org.osate.aadl2.instance.FlowSpecificationInstance
import org.osate.aadl2.instance.InstanceObject
import org.osate.aadl2.instance.ModeInstance
import org.osate.aadl2.instance.SystemInstance

import static extension org.eclipse.emf.ecore.util.EcoreUtil.resolve
import static extension org.eclipse.xtext.EcoreUtil2.eAllContentsAsList
import static extension org.eclipse.xtext.EcoreUtil2.getContainerOfType
import static extension org.eclipse.xtext.scoping.Scopes.scopeFor
import static extension org.eclipse.xtext.scoping.Scopes.scopedElementsFor
import static extension org.osate.aadl2.modelsupport.util.AadlUtil.getBasePropertyType

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class InstanceScopeProvider extends AbstractDeclarativeScopeProvider {
	val static TRANSITION_NAME_GETTER = [List<ModeTransition> list, ModeTransition element | element.name ?: "transition#" + list.indexOf(element)]
	
	val ResourceDescriptionsProvider rdp
	
	@Inject
	new(ResourceDescriptionsProvider rdp) {
		this.rdp = rdp
	}
	
	def IScope scope_FeatureInstance_feature(EObject context, EReference reference) {
		val fromComponents = <ComponentType>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentType, [ownedFeatures])
		val fromFeatureGroups = <FeatureGroupType>getDeclarativeScope(context, Aadl2Package.eINSTANCE.featureGroupType, [ownedFeatures])
		new SimpleScope(fromComponents + fromFeatureGroups)
	}
	
	def IScope scope_FlowSpecificationInstance(ComponentInstance context, EReference reference) {
		context.flowSpecifications.scopeFor
	}
	
	def IScope scope_ConnectionInstance(EObject context, EReference reference) {
		switch parent : context.eContainer.getContainerOfType(ComponentInstance) {
			case null: IScope.NULLSCOPE
			default: new SimpleScope(doConnection(0, parent))
		}
	}
	
	def IScope scope_ComponentInstance_inMode(ComponentInstance context, EReference reference) {
		val parent = context.eContainer.getContainerOfType(ComponentInstance)
		(parent?.modeInstances ?: emptyList).scopeFor
	}
	
	def IScope scope_ComponentInstance_subcomponent(EObject context, EReference reference) {
		new SimpleScope(<ComponentImplementation>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentImplementation, [ownedSubcomponents]))
	}
	
	def IScope scope_ConnectionInstanceEnd(ComponentInstance context, EReference reference) {
		new SimpleScope(context.getInstanceScope(FeatureInstance, ComponentInstance))
	}
	
	def IScope scope_SystemOperationMode(SystemInstance context, EReference reference) {
		new SimpleScope(context.systemOperationModes.indexed.map[EObjectDescription.create(key.toString, value)])
	}
	
	def IScope scope_ModeTransitionInstance(ComponentInstance context, EReference reference) {
		new SimpleScope(context.modeTransitionInstances.indexed.map[EObjectDescription.create(key.toString, value)])
	}
	
	def IScope scope_ConnectionReference_connection(EObject context, EReference reference) {
		new SimpleScope(<ComponentImplementation>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentImplementation, [ownedConnections]))
	}
	
	def IScope scope_ConnectionReference_context(ComponentInstance context, EReference reference) {
		new SimpleScope(#[EObjectDescription.create("parent", context)] + context.getInstanceScope(ComponentInstance))
	}
	
	def IScope scope_FeatureInstance(ComponentInstance context, EReference reference) {
		new SimpleScope(context.getInstanceScope(FeatureInstance))
	}
	
	def IScope scope_ModeInstance(ComponentInstance context, EReference reference) {
		context.modeInstances.scopeFor
	}
	
	def IScope scope_FlowSpecificationInstance_flowSpecification(EObject context, EReference reference) {
		new SimpleScope(<ComponentType>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentType, [ownedFlowSpecifications]))
	}
	
	def IScope scope_EndToEndFlowInstance_flowElement(ComponentInstance context, EReference reference) {
		new SimpleScope(context.getInstanceScope(ComponentInstance, ConnectionInstance, EndToEndFlowInstance, FlowSpecificationInstance))
	}
	
	def IScope scope_EndToEndFlowInstance_endToEndFlow(EObject context, EReference reference) {
		new SimpleScope(<ComponentImplementation>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentImplementation, [ownedEndToEndFlows]))
	}
	
	def IScope scope_ModeInstance_parent(ComponentInstance context, EReference reference) {
		val parent = context.eContainer.getContainerOfType(ComponentInstance)
		(parent?.modeInstances ?: emptyList).scopeFor
	}
	
	def IScope scope_ModeInstance_mode(EObject context, EReference reference) {
		new SimpleScope(<ComponentClassifier>getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentClassifier, [ownedModes]))
	}
	
	def IScope scope_ModeTransitionInstance_modeTransition(EObject context, EReference reference) {
		new SimpleScope(getDeclarativeScope(context, Aadl2Package.eINSTANCE.componentClassifier, [ComponentClassifier it | ownedModeTransitions], TRANSITION_NAME_GETTER))
	}
	
	def IScope scope_SystemOperationMode_currentMode(ComponentInstance context, EReference reference) {
		new SimpleScope(context.getInstanceScope(ModeInstance))
	}
	
	def IScope scope_PropertyAssociationInstance_propertyAssociation(EObject context, EReference reference) {
		val rds = rdp.getResourceDescriptions(context.eResource)
		val classifierDescriptions = rds.getExportedObjectsByType(Aadl2Package.eINSTANCE.classifier)
		val classifiers = classifierDescriptions.map[EObjectOrProxy.resolve(context) as Classifier]
		new SimpleScope(classifiers.map[classifier |
			val pkgName = classifier.getContainerOfType(AadlPackage).name
			val directAssociations = classifier.ownedPropertyAssociations.indexed.map[propertyAssociation |
				val qualifiedName = QualifiedName.create(pkgName.split("::") + #[classifier.name, propertyAssociation.key.toString])
				EObjectDescription.create(qualifiedName, propertyAssociation.value)
			]
			val indirectAssociations = switch classifier {
				FeatureGroupType: getAssociationScope(pkgName, classifier.name, classifier.ownedFeatures)
				ComponentType: classifier.ownedModeTransitions.getAssociationScope(pkgName, classifier.name, TRANSITION_NAME_GETTER) + getAssociationScope(
					pkgName, classifier.name, classifier.ownedFeatures, classifier.ownedFlowSpecifications, classifier.ownedModes
				)
				ComponentImplementation: classifier.ownedModeTransitions.getAssociationScope(pkgName, classifier.name, TRANSITION_NAME_GETTER) + getAssociationScope(
					pkgName, classifier.name, classifier.ownedSubcomponents, classifier.ownedConnections, classifier.ownedEndToEndFlows, classifier.ownedModes
				)
			}
			directAssociations + indirectAssociations
		].flatten)
	}
	
	def IScope scope_ModalElement_inMode(SystemInstance context, EReference reference) {
		scope_SystemOperationMode(context, reference)
	}
	
	/*
	 * Copied from PropertiesScopeProvider.  Ideally, this class should extend from PropertiesScopeProvider, but this
	 * cannot be done because the Properties language is case-insensitive and this language is case-sensitive.  The two
	 * scope providers call different versions of the method scopeFor.  PropertiesScopeProvider should really be
	 * modified so that it can be extended and used in case-sensitive languages.
	 */
	def IScope scope_NumberValue_unit(PropertyAssociation context, EReference reference) {
		createUnitLiteralsScopeFromPropertyType(context.property.propertyType)
	}
	
	/*
	 * Copied from PropertiesScopeProvider.  Ideally, this class should extend from PropertiesScopeProvider, but this
	 * cannot be done because the Properties language is case-insensitive and this language is case-sensitive.  The two
	 * scope providers call different versions of the method scopeFor.  PropertiesScopeProvider should really be
	 * modified so that it can be extended and used in case-sensitive languages.
	 */
	def IScope scope_NumberValue_unit(BasicPropertyAssociation context, EReference reference) {
		createUnitLiteralsScopeFromPropertyType(context.property.propertyType)
	}
	
	/*
	 * Copied from PropertiesScopeProvider.  Ideally, this class should extend from PropertiesScopeProvider, but this
	 * cannot be done because the Properties language is case-insensitive and this language is case-sensitive.  The two
	 * scope providers call different versions of the method scopeFor.  PropertiesScopeProvider should really be
	 * modified so that it can be extended and used in case-sensitive languages.
	 */
	def IScope scope_NamedValue_namedValue(Element context, EReference reference) {
		val property = context.getContainerOfType(BasicPropertyAssociation)?.property ?: context.getContainerOfType(PropertyAssociation).property
		switch baseType : property.propertyType.basePropertyType {
			EnumerationType: baseType.ownedLiterals.scopeFor(delegateGetScope(context, reference))
			default: delegateGetScope(context, reference)
		}
	}
	
	def IScope scope_BasicPropertyAssociation_property(RecordValue context, EReference reference) {
		val property = context.getContainerOfType(BasicPropertyAssociation)?.property ?: context.getContainerOfType(PropertyAssociation).property
		switch baseType : property.propertyType.basePropertyType {
			RecordType: baseType.ownedFields.scopeFor
			default: IScope.NULLSCOPE
		}
	}
	
	def IScope scope_ContainmentPathElement_namedElement(EObject context, EReference reference) {
		val rds = rdp.getResourceDescriptions(context.eResource)
		val classifierDescriptions = rds.getExportedObjectsByType(Aadl2Package.eINSTANCE.classifier)
		val classifiers = classifierDescriptions.map[EObjectOrProxy.resolve(context) as Classifier]
		new SimpleScope(classifiers.map[classifier |
			val pkgName = classifier.getContainerOfType(AadlPackage).name
			val elements = switch classifier {
				FeatureGroupType: classifier.ownedPrototypes + classifier.ownedFeatureGroups
				ComponentType: classifier.ownedPrototypes + classifier.ownedFeatureGroups
				BehavioredImplementation: classifier.implReferenceElements + classifier.ownedSubprogramCallSequences + classifier.subprogramCalls()
				ComponentImplementation: classifier.implReferenceElements
			}
			elements.map[element |
				val qualifiedName = QualifiedName.create(pkgName.split("::") + #[classifier.name, element.name])
				EObjectDescription.create(qualifiedName, element)
			]
		].flatten)
	}
	
	def IScope scope_InstanceReferenceValue_referencedInstanceObject(SystemInstance context, EReference reference) {
		new SimpleScope(context.getInstanceScope(FeatureInstance, FlowSpecificationInstance, ModeInstance, ComponentInstance, ConnectionInstance, EndToEndFlowInstance))
	}
	
	def private static Iterable<IEObjectDescription> doConnection(int levelCount, ComponentInstance component) {
		val descriptions = component.connectionInstances.indexed.map[
			EObjectDescription.create('''«IF levelCount > 0»«levelCount»~«ENDIF»«key»''', value)
		]
		switch parent : component.eContainer {
			ComponentInstance: descriptions + doConnection(levelCount + 1, parent)
			default: descriptions
		}
	}
	
	def private <T extends Classifier> getDeclarativeScope(EObject context, EClass containerEClass, (T)=>List<? extends NamedElement> elementsGetter) {
		getDeclarativeScope(context, containerEClass, elementsGetter, [list, element | element.name])
	}
	
	def private <C extends Classifier, E extends NamedElement> getDeclarativeScope(EObject context, EClass containerEClass, (C)=>List<E> elementsGetter, (List<E>, E)=>String nameGetter) {
		val rds = rdp.getResourceDescriptions(context.eResource)
		val classifierDescriptions = rds.getExportedObjectsByType(containerEClass)
		val classifiers = classifierDescriptions.map[EObjectOrProxy.resolve(context) as C]
		classifiers.map[classifier |
			val pkgName = classifier.getContainerOfType(AadlPackage).name
			val elements = elementsGetter.apply(classifier)
			elements.map[element |
				val qualifiedName = QualifiedName.create(pkgName.split("::") + #[classifier.name, nameGetter.apply(elements, element)])
				EObjectDescription.create(qualifiedName, element)
			]
		].flatten
	}
	
	def private getInstanceScope(ComponentInstance context, Class<?>... types) {
		context.eAllContentsAsList.filter[element | types.exists[isInstance(element)]].scopedElementsFor[QualifiedName.create(getInstanceScopeName(context))]
	}
	
	def private static String getInstanceScopeName(EObject element, ComponentInstance root) {
		val prefix = if (element.eContainer == root) {
			""
		} else {
			getInstanceScopeName(element.eContainer, root) + "."
		}
		prefix + switch element {
			ComponentInstance: '''«element.name»«FOR index : element.indices»[«index»]«ENDFOR»'''
			ConnectionInstance: element.getContainerOfType(ComponentInstance).connectionInstances.indexOf(element)
			FeatureInstance: '''«element.name»«IF element.index != 0»[«element.index»]«ENDIF»'''
			InstanceObject: element.name
		}
	}
	
	def private static getAssociationScope(String pkgName, String classifierName, List<? extends NamedElement>... lists) {
		lists.map[getAssociationScope(pkgName, classifierName, [list, element | element.name])].flatten
	}
	
	def private static <T extends NamedElement> getAssociationScope(List<T> list, String pkgName, String classifierName, (List<T>, T)=>String getName) {
		list.map[element | element.ownedPropertyAssociations.indexed.map[propertyAssociation |
			val qualifiedName = QualifiedName.create(pkgName.split("::") + #[classifierName, getName.apply(list, element), propertyAssociation.key.toString])
			EObjectDescription.create(qualifiedName, propertyAssociation.value)
		]].flatten
	}
	
	/*
	 * Copied from PropertiesScopeProvider.  Ideally, this class should extend from PropertiesScopeProvider, but this
	 * cannot be done because the Properties language is case-insensitive and this language is case-sensitive.  The two
	 * scope providers call different versions of the method scopeFor.  PropertiesScopeProvider should really be
	 * modified so that it can be extended and used in case-sensitive languages.
	 */
	def private static createUnitLiteralsScopeFromPropertyType(PropertyType type) {
		switch baseType : type.basePropertyType {
			NumberType: baseType.unitsType
			RangeType: baseType.numberType.unitsType
		}?.ownedLiterals?.scopeFor ?: IScope.NULLSCOPE
	}
	
	def private static getImplReferenceElements(ComponentImplementation impl) {
		impl.ownedPrototypes + impl.ownedSubcomponents + impl.ownedInternalFeatures + impl.ownedProcessorFeatures
	}
}