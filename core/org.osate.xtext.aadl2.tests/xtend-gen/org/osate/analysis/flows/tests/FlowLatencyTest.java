package org.osate.analysis.flows.tests;

import com.google.common.base.Objects;
import java.io.InputStream;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.junit4.InjectWith;
import org.eclipse.xtext.util.Files;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function0;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipselabs.xtext.utils.unittesting.FluentIssueCollection;
import org.eclipselabs.xtext.utils.unittesting.XtextRunner2;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.osate.aadl2.AadlPackage;
import org.osate.aadl2.Classifier;
import org.osate.aadl2.PublicPackageSection;
import org.osate.aadl2.SystemImplementation;
import org.osate.aadl2.instance.SystemInstance;
import org.osate.aadl2.instance.SystemOperationMode;
import org.osate.aadl2.instantiation.InstantiateModel;
import org.osate.aadl2.modelsupport.errorreporting.AnalysisErrorReporterManager;
import org.osate.analysis.flows.actions.CheckFlowLatency;
import org.osate.xtext.aadl2.Aadl2UiInjectorProvider;
import org.osate.xtext.aadl2.tests.OsateTest;

@RunWith(XtextRunner2.class)
@InjectWith(Aadl2UiInjectorProvider.class)
@SuppressWarnings("all")
public class FlowLatencyTest extends OsateTest {
  private final String projectRoot = "platform:/resource/test/";
  
  /**
   * Must build workspace before running any test. Otherwise we get exceptions.
   */
  @Before
  public void setUp() {
    final IProject test_project = this.createProject("test", "packages");
    this.buildProject("Plugin_Resources", true);
    this.setResourceRoot((this.projectRoot + "packages"));
  }
  
  @Test
  public void flows_pullprotocols() {
    try {
      final String pullprotocolsFile = "pullprotocols.aadl";
      Pair<String, String> _mappedTo = Pair.<String, String>of(pullprotocolsFile, this.pullprotocolsText);
      this.createFiles(_mappedTo);
      this.suppressSerialization();
      final FluentIssueCollection result = this.testFile(pullprotocolsFile);
      Resource _resource = result.getResource();
      EList<EObject> _contents = _resource.getContents();
      EObject _head = IterableExtensions.<EObject>head(_contents);
      final AadlPackage pkg = ((AadlPackage) _head);
      PublicPackageSection _ownedPublicSection = pkg.getOwnedPublicSection();
      final EList<Classifier> cls = _ownedPublicSection.getOwnedClassifiers();
      final Function1<Classifier, Boolean> _function = new Function1<Classifier, Boolean>() {
        public Boolean apply(final Classifier it) {
          String _name = it.getName();
          return Boolean.valueOf(Objects.equal(_name, "stub.i"));
        }
      };
      boolean _exists = IterableExtensions.<Classifier>exists(cls, _function);
      Assert.assertTrue("", _exists);
      final Function1<Classifier, Boolean> _function_1 = new Function1<Classifier, Boolean>() {
        public Boolean apply(final Classifier it) {
          String _name = it.getName();
          return Boolean.valueOf(Objects.equal(_name, "stub.i"));
        }
      };
      Iterable<Classifier> _filter = IterableExtensions.<Classifier>filter(cls, _function_1);
      Classifier _head_1 = IterableExtensions.<Classifier>head(_filter);
      final SystemImplementation sysImpl = ((SystemImplementation) _head_1);
      final SystemInstance instance = InstantiateModel.buildInstanceModelFile(sysImpl);
      String _name = instance.getName();
      Assert.assertEquals("stub_i_Instance", _name);
      final AnalysisErrorReporterManager errorManager = AnalysisErrorReporterManager.NULL_ERROR_MANANGER;
      final CheckFlowLatency checker = new CheckFlowLatency();
      EList<SystemOperationMode> _systemOperationModes = instance.getSystemOperationModes();
      final SystemOperationMode som = IterableExtensions.<SystemOperationMode>head(_systemOperationModes);
      NullProgressMonitor _nullProgressMonitor = new NullProgressMonitor();
      checker.invoke(_nullProgressMonitor, errorManager, instance, som);
      final URI uri = URI.createURI(
        (this.projectRoot + "instances/reports/latency/pullprotocols_stub_i_Instance__latencylatency.csv"));
      String _platformString = uri.toPlatformString(true);
      Path _path = new Path(_platformString);
      final IFile file = this.workspaceRoot.getFile(_path);
      InputStream _contents_1 = file.getContents();
      final String actual = Files.readStreamIntoString(_contents_1);
      String _trim = this.expected.trim();
      String _trim_1 = actual.trim();
      Assert.assertEquals("error", _trim, _trim_1);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private final String pullprotocolsText = new Function0<String>() {
    public String apply() {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("package PullProtocols");
      _builder.newLine();
      _builder.append("public");
      _builder.newLine();
      _builder.newLine();
      _builder.append("virtual bus DCFMInputPullProtocol");
      _builder.newLine();
      _builder.append("properties");
      _builder.newLine();
      _builder.append("Transmission_Type => pull;");
      _builder.newLine();
      _builder.append("Latency => 300 ms .. 300 ms ; -- should be allowed on virtual bus");
      _builder.newLine();
      _builder.append("-- Implemented_As => classifier (PullDCFMInputDataset.CrossPartition);");
      _builder.newLine();
      _builder.append("-- implemented_as wants a system implementation or an abstract implementation");
      _builder.newLine();
      _builder.append("-- On the other hand latency analysis currently assumes that threads sit inside processes for one way of recognizing partition boundaries.");
      _builder.newLine();
      _builder.append("end DCFMInputPullProtocol;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("process PullDCFMInputDataset");
      _builder.newLine();
      _builder.append("features");
      _builder.newLine();
      _builder.append("SenderData: in data port ;");
      _builder.newLine();
      _builder.append("ReceiverData: out data port ;");
      _builder.newLine();
      _builder.append("flows");
      _builder.newLine();
      _builder.append("Xfer: flow path SenderData -> ReceiverData;");
      _builder.newLine();
      _builder.append("end PullDCFMInputDataset; ");
      _builder.newLine();
      _builder.newLine();
      _builder.append("process implementation PullDCFMInputDataset.CrossPartition");
      _builder.newLine();
      _builder.append("subcomponents");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("sender: thread PullDCFMDataSetSender;");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("requestor: thread PullDCFMDataSetRequestor;");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("connections");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("incoming: port SenderData -> sender.SenderData;");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("outgoing: port requestor.ReceiverData -> ReceiverData;");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("STRequest: port requestor.SourceTracksRequest -> sender.SourceTracksRequest;");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("STReply: port sender.SendSourceTrackSet -> requestor.ReceivedSourceTrackSet");
      _builder.newLine();
      _builder.append(" \t\t");
      _builder.append("{Required_Virtual_Bus_Class => (classifier (PullProtocols::DCFMInputPullProtocol));};");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("CTRequest: port requestor.CorrelatedTracksRequest -> sender.CorrelatedTracksRequest;");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("CTReply: port sender.SendCorrelatedTrackSet -> requestor.ReceivedCorrelatedTrackSet;");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("APRequest: port requestor.OwnAircraftPositionRequest -> sender.OwnAircraftPositionRequest;");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("APReply: port sender.SendOwnAircraftPosition -> requestor.ReceivedOwnAircraftPosition;");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("flows");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("-- flow to measure latency of protocol. The result is to be reflected in the latency property of the virtual bus it implements");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("XferOnly: end to end flow sender.SourceTrackFlow -> STReply -> requestor.SourceTrackReceivedFlow -> CTRequest ->");
      _builder.newLine();
      _builder.append(" \t\t");
      _builder.append("sender.CorrelatedFlow -> CTReply -> requestor.CorrelatedTrackReceivedFlow -> ");
      _builder.newLine();
      _builder.append(" \t\t");
      _builder.append("APRequest -> sender.AircraftPositionFlow -> APReply -> requestor.AircraftPositionReceivedFlow");
      _builder.newLine();
      _builder.append(" \t\t");
      _builder.append(";--{Latency => 10 ms .. 10 ms;};");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("-- flow to be used when abstract implementation is used in the transfer instead of a protocol binding ");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("Xfer: flow path SenderData -> incoming -> sender.SenderDataSetFLow -> STReply -> requestor.SourceTrackReceivedFlow -> CTRequest ->");
      _builder.newLine();
      _builder.append(" \t\t");
      _builder.append("sender.CorrelatedFlow -> CTReply -> requestor.CorrelatedTrackReceivedFlow -> APRequest -> sender.AircraftPositionFlow -> APReply -> requestor.ReceivedDataSetFlow");
      _builder.newLine();
      _builder.append(" \t\t");
      _builder.append("-> outgoing -> ReceiverData;");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("properties");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("-- alternating immediate/delayed emulates partition slots and communication within a frame.");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("-- making all dealeyd emulates frame delayed corss partition communication.");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("-- we could also indicates partitions by tagging the process as SEI::isPartition and a SEI::Partition_Latency");
      _builder.newLine();
      _builder.append(" \t");
      _builder.append("-- Alternatively we can use virtual processor and the ARINC653 properties or the period on the virtual processor");
      _builder.newLine();
      _builder.append(" \t\t");
      _builder.append("Timing => Immediate applies to STRequest,CTRequest,APRequest;");
      _builder.newLine();
      _builder.append(" \t\t");
      _builder.append("Timing => Delayed applies to STReply,CTReply,APReply;");
      _builder.newLine();
      _builder.append(" \t\t");
      _builder.append("Latency => 10 ms .. 10 ms applies to XferOnly;");
      _builder.newLine();
      _builder.append(" \t\t");
      _builder.append("Period => 100 ms applies to sender, requestor;");
      _builder.newLine();
      _builder.append(" \t\t");
      _builder.append("Dispatch_Protocol => Periodic applies to sender, requestor;");
      _builder.newLine();
      _builder.append("end PullDCFMInputDataset.CrossPartition;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("system stub");
      _builder.newLine();
      _builder.append("end stub;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("system implementation stub.i");
      _builder.newLine();
      _builder.append("subcomponents");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("prot: process PullDCFMInputDataset.CrossPartition;");
      _builder.newLine();
      _builder.append("end stub.i;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("thread PullDCFMDataSetSender");
      _builder.newLine();
      _builder.append("features");
      _builder.newLine();
      _builder.append("-- data to be transferred");
      _builder.newLine();
      _builder.append("SenderData: in data port  ;");
      _builder.newLine();
      _builder.append("-- protocol interaction ports");
      _builder.newLine();
      _builder.append("SourceTracksRequest: in data port;");
      _builder.newLine();
      _builder.append("SendSourceTrackSet: out data port ;");
      _builder.newLine();
      _builder.append("CorrelatedTracksRequest: in data port;");
      _builder.newLine();
      _builder.append("SendCorrelatedTrackSet: out data port ;");
      _builder.newLine();
      _builder.append("OwnAircraftPositionRequest: in data port;");
      _builder.newLine();
      _builder.append("SendOwnAircraftPosition: out data port  ;");
      _builder.newLine();
      _builder.append("flows");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("SenderDataSetFLow: flow path SenderData -> SendSourceTrackSet;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("SourceTrackFlow: flow source SendSourceTrackSet;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("SourceTrackFlowpath: flow path SourceTracksRequest->SendSourceTrackSet;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("CorrelatedFlow: flow path CorrelatedTracksRequest -> SendCorrelatedTrackSet;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("AircraftPositionFlow: flow path OwnAircraftPositionRequest -> SendOwnAircraftPosition;");
      _builder.newLine();
      _builder.append("properties");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("Dispatch_Protocol => Periodic;");
      _builder.newLine();
      _builder.append("end PullDCFMDataSetSender;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("thread PullDCFMDataSetRequestor");
      _builder.newLine();
      _builder.append("features");
      _builder.newLine();
      _builder.append("-- data being transferred");
      _builder.newLine();
      _builder.append("ReceiverData: out data port  ;");
      _builder.newLine();
      _builder.append("-- protocol interaction ports");
      _builder.newLine();
      _builder.append("SourceTracksRequest: out data port;");
      _builder.newLine();
      _builder.append("ReceivedSourceTrackSet: in data port ;");
      _builder.newLine();
      _builder.append("CorrelatedTracksRequest: out data port;");
      _builder.newLine();
      _builder.append("ReceivedCorrelatedTrackSet: in data port ;");
      _builder.newLine();
      _builder.append("OwnAircraftPositionRequest: out data port;");
      _builder.newLine();
      _builder.append("ReceivedOwnAircraftPosition: in data port  ;");
      _builder.newLine();
      _builder.append("flows");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("SourceTrackRequestFlow: flow source SourceTracksRequest;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("SourceTrackReceivedFlow: flow path ReceivedSourceTrackSet -> CorrelatedTracksRequest;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("CorrelatedTrackReceivedFlow: flow path ReceivedCorrelatedTrackSet -> OwnAircraftPositionRequest;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("AircraftPositionReceivedFlow: flow sink ReceivedOwnAircraftPosition ;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("ReceivedDataSetFlow: flow path ReceivedOwnAircraftPosition -> ReceiverData;");
      _builder.newLine();
      _builder.append("properties");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("Dispatch_Protocol => Periodic;");
      _builder.newLine();
      _builder.append("end PullDCFMDataSetRequestor;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("end PullProtocols;");
      return _builder.toString();
    }
  }.apply();
  
  private final String expected = new Function0<String>() {
    public String apply() {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Latency Analysis Report");
      _builder.newLine();
      _builder.newLine();
      _builder.append("Flow analysis for end to end flow XferOnly");
      _builder.newLine();
      _builder.append("Contributor,Min Specified,Min Value,Min Method,Max Specified,Max Value,Max Method,Comments,");
      _builder.newLine();
      _builder.append("Thread sender,,100.0ms,deadline,,100.0ms,deadline,Time to take to send the data over the network,");
      _builder.newLine();
      _builder.append("Delayed Connection sender.SendSourceTrackSet -> requestor.ReceivedSourceTrackSet,,0.0ms,period,,100.0ms,period,Data might arrive at dispatch time or next frame,");
      _builder.newLine();
      _builder.append("Protocol DCFMInputPullProtocol,,300.0ms,specified,,300.0ms,specified,Time required by the protocol stack,");
      _builder.newLine();
      _builder.append("Thread requestor,,0.0ms,immediate connection,,0.0ms,immediate connection,The connection is immediate and both parts are synchronized. Using either the min/max execution or assume execution time is negligible,");
      _builder.newLine();
      _builder.append("Immediate Connection requestor.CorrelatedTracksRequest -> sender.CorrelatedTracksRequest,,0.0ms,unknown,,0.0ms,unknown,,");
      _builder.newLine();
      _builder.append("Thread sender,,100.0ms,deadline,,100.0ms,deadline,Time to take to send the data over the network,");
      _builder.newLine();
      _builder.append("Delayed Connection sender.SendCorrelatedTrackSet -> requestor.ReceivedCorrelatedTrackSet,,0.0ms,period,,100.0ms,period,Data might arrive at dispatch time or next frame,");
      _builder.newLine();
      _builder.append("Thread requestor,,0.0ms,immediate connection,,0.0ms,immediate connection,The connection is immediate and both parts are synchronized. Using either the min/max execution or assume execution time is negligible,");
      _builder.newLine();
      _builder.append("Immediate Connection requestor.OwnAircraftPositionRequest -> sender.OwnAircraftPositionRequest,,0.0ms,unknown,,0.0ms,unknown,,");
      _builder.newLine();
      _builder.append("Thread sender,,100.0ms,deadline,,100.0ms,deadline,Time to take to send the data over the network,");
      _builder.newLine();
      _builder.append("Delayed Connection sender.SendOwnAircraftPosition -> requestor.ReceivedOwnAircraftPosition,,0.0ms,period,,100.0ms,period,Data might arrive at dispatch time or next frame,");
      _builder.newLine();
      _builder.append("Thread requestor,,100.0ms,deadline,,100.0ms,deadline,,");
      _builder.newLine();
      _builder.append("Total,0.0ms,700.0ms,,0.0ms,900.0ms,,");
      _builder.newLine();
      _builder.append("Flow Specification,,0.0ms,,,0.0ms,,");
      _builder.newLine();
      _builder.append("Informations,the minimal latency is not specified,");
      _builder.newLine();
      _builder.append(",the maximal latency is not specified,");
      _builder.newLine();
      return _builder.toString();
    }
  }.apply();
}
