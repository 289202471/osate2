grammar org.osate.xtext.aadl2.Aadl2 with //org.osate.xtext.aadl2.properties.Properties
org.eclipse.xtext.common.Terminals
//generate aadl2 "http://www.osate.org/aadl2/Aadl2"

import "platform:/resource/org.osate.aadl2/model/aadl2.ecore" as aadl2

//testing push


AadlPackage returns aadl2::AadlPackage:
	'package' name=PNAME
	((ownedPublicSection=PublicPackageSection
	(ownedPrivateSection=PrivatePackageSection)?) |
	ownedPrivateSection=PrivatePackageSection)
	(=> 'properties'
	((ownedPropertyAssociation+=PropertyAssociation)+ ))? //| noProperties?=NONE
	'end' ID ('::' ID)* SEMI;


PublicPackageSection returns aadl2::PublicPackageSection:
	{aadl2::PublicPackageSection}
	'public'
	(=> 'with' (importedPackage+=[aadl2::AadlPackage|PNAME]) //| importedPropertySet+=[props::PropertySet|ID]) 
	(COMMA importedPackage+=[aadl2::AadlPackage|PNAME])* SEMI)*
	    ( ownedSystemType+=SystemType| ownedSystemImplementation+=SystemImplementation| ownedProcessorType+=ProcessorType|
	    ownedDataType+=DataType )*;
	// currently derived: (ownedClassifier+=Classifier | ownedAnnexLibrary+=AnnexLibrary)*;


PrivatePackageSection returns aadl2::PrivatePackageSection:
	{aadl2::PrivatePackageSection}
	'private'
	(=> 'with' (importedPackage+=[aadl2::AadlPackage|PNAME]) //| importedPropertySet+=[props::PropertySet|ID]) 
	(COMMA importedPackage+=[aadl2::AadlPackage|PNAME])* SEMI)*
    ( ownedSystemType+=SystemType| ownedSystemImplementation+=SystemImplementation| ownedProcessorType+=ProcessorType|
    ownedDataType+=DataType )*
//	(ownedClassifier+=Classifier | ownedAnnexLibrary+=AnnexLibrary)*
	;


//Classifier returns aadl2::Classifier:
//	ComponentClassifier | FeatureGroupType;
//
//ComponentClassifier returns aadl2::ComponentClassifier:
//	SystemClassifier | DataClassifier|ProcessorClassifier|ProcessClassifier|ThreadClassifier;


TypeExtension returns aadl2::TypeExtension:
	'extends' extended=[aadl2::ComponentType|QCREF];

ImplementationExtension returns aadl2::ImplementationExtension:
	'extends' extended=[aadl2::ComponentImplementation|QCREF];



ComponentCategoryKW returns aadl2::ComponentCategory: 'abstract' | 'bus'|'data'
	| 'device' | 'memory' | 'process' | 'processor'
	| 'subprogram' 'group' | 'system' | 'thread' 'group'
	| 'thread' | 'virtual' 'bus' | 'virtual' 'processor';

// DOES NOT WORK: the other rules invoke the sub-type rule which does not do the rest.
//ComponentType returns aadl2::ComponentType:
//	SystemType | ProcessType | ThreadType | DataType | ProcessorType | SystemType
//	(=> 'flows'
//	((ownedFlowSpecification+=FlowSpecification)+ | noFlows?=NONE))?
////	(=> requiresModes?='requires' 'modes'
////	((ownedMode+=Mode)+))?
//	(=> 'modes' ((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+) | noModes?=NONE)?
////	(=> 'properties'
////	((ownedPropertyAssociation+=PropertyAssociation)+
////	| noProperties?=NONE))?
//	(ownedAnnexSubclause+=AnnexSubclause)*
//	'end' ID SEMI
//; 

SystemType returns aadl2::SystemType:
	'system' name=ID
//	(ownedExtension=TypeExtension)?
//	(=> 'extends' extends=[aadl2::SystemType|QCREF])?
	(=> 'prototypes' (noPrototypes?=NONE |
	(ownedPrototype+=Prototype)+))?
	(=> 'features' (noFeatures?=NONE |
	(ownedDataPort+=DataPort| ownedEventPort+=EventPort | ownedEventDataPort+=EventDataPort)+ ) )?
//	(ownedFeature+=(DataPort | EventPort | EventDataPort | FeatureGroup))+))? //| FeatureGroup
	(=> 'flows'
	((ownedFlowSpecification+=FlowSpecification)+ | noFlows?=NONE))?
//	(=> requiresModes?='requires' 'modes'
//	((ownedMode+=Mode)+))?
	(=> 'modes' ((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+) | noModes?=NONE)?
	(=> 'properties'
	((ownedPropertyAssociation+=PropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID SEMI
	;


ProcessType returns aadl2::ProcessType:
	'process' name=ID
//	(ownedExtension=TypeExtension)?
//	(=> 'extends' extends=[aadl2::ProcessType|QCREF])?
	(=> 'prototypes' (noPrototypes?=NONE |
	(ownedPrototype+=Prototype)+))?
	(=> 'features' (noFeatures?=NONE |
	(ownedDataPort+=DataPort| ownedEventPort+=EventPort | ownedEventDataPort+=EventDataPort)+ ) )?
//	(ownedFeature+=(DataPort | EventPort | EventDataPort))+))?
	(=> 'flows'
	((ownedFlowSpecification+=FlowSpecification)+ | noFlows?=NONE))?
//	(=> requiresModes?='requires' 'modes'
//	((ownedMode+=Mode)+))?
	(=> 'modes' ((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+) | noModes?=NONE)?
	(=> 'properties'
	((ownedPropertyAssociation+=PropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID SEMI
	;


ThreadType returns aadl2::ThreadType:
	'thread' name=ID
//	(ownedExtension=TypeExtension)?
//	(=> 'extends' extends=[aadl2::ThreadType|QCREF])?
	(=> 'prototypes' (noPrototypes?=NONE |
	(ownedPrototype+=Prototype)+))?
	(=> 'features' (noFeatures?=NONE |
	(ownedDataPort+=DataPort| ownedEventPort+=EventPort | ownedEventDataPort+=EventDataPort)+ ) )?
//	(ownedFeature+=(DataPort | EventPort | EventDataPort))+))?
	(=> 'flows'
	((ownedFlowSpecification+=FlowSpecification)+ | noFlows?=NONE))?
//	(=> requiresModes?='requires' 'modes'
//	((ownedMode+=Mode)+))?
	(=> 'modes' ((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+) | noModes?=NONE)?
	(=> 'properties'
	((ownedPropertyAssociation+=PropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID SEMI
	;


ProcessorType returns aadl2::ProcessorType:
	'processor' name=ID
//	(=> 'extends' extends=[aadl2::ProcessorType|QCREF])?
//	(ownedExtension=TypeExtension)?
	(=> 'features' (noFeatures?=NONE |
	(ownedDataPort+=DataPort| ownedEventPort+=EventPort | ownedEventDataPort+=EventDataPort)+ ) )?
//	(ownedFeature+=(DataPort | EventPort | EventDataPort))+))?
	(=> 'flows'
	((ownedFlowSpecification+=FlowSpecification)+ | noFlows?=NONE))?
//	(=> requiresModes?='requires' 'modes'
//	((ownedMode+=Mode)+))?
	(=> 'modes' ((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+) | noModes?=NONE)?
	(=> 'properties'
	((ownedPropertyAssociation+=PropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID SEMI
	;


DataType returns aadl2::DataType:
	'data' name=ID
//	(=> 'extends' extends=[aadl2::DataType|QCREF])?
//	(ownedExtension=TypeExtension)?
	(=> 'features' noFeatures?=NONE 
//	| (ownedDataPort+=DataPort| ownedEventPort+=EventPort | ownedEventDataPort+=EventDataPort)+ )
	 )?
//	(ownedFeature+=(DataPort | EventPort | EventDataPort))+))?
	(=> 'flows'
	((ownedFlowSpecification+=FlowSpecification)+ | noFlows?=NONE))?
//	(=> requiresModes?='requires' 'modes'
//	((ownedMode+=Mode)+))?
	(=> 'modes' ((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+) | noModes?=NONE)?
	(=> 'properties'
	((ownedPropertyAssociation+=PropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID SEMI
	;


SystemImplementation returns aadl2::SystemImplementation:
	{aadl2::SystemImplementation}
	'system' 'implementation' 
	// sealed type
//	ownedRealization=Realization DOT name=INAME
//	(ownedExtension=ImplementationExtension)?
//	implemented=[aadl2::ComponentType|ID] DOT name=INAME
//	(=> 'extends' extends=[aadl2::SystemImplementation|QCREF])?
	(=> 'subcomponents'
	  ((ownedSystemSubcomponent+=SystemSubcomponent
	  |ownedProcessorSubcomponent+=ProcessorSubcomponent
	  |ownedDataSubcomponent+=DataSubcomponent)+
	// ownedSubcomponent instaed of each subclass
//	((ownedSubcomponent+=Subcomponent )+
	| noSubcomponents?=NONE)
	)?
	(=> 'connections'
	((ownedPortConnection+=PortConnection)+
	| noConnections?=NONE))?
	(=> 'flows'
	(noFlows?=NONE))?
	(=> 'modes'
	((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+
	| noModes?=NONE))?
	(=> 'properties'
	((ownedPropertyAssociation+=PropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID DOT INAME SEMI
	;

DataImplementation returns aadl2::DataImplementation:
	{aadl2::DataImplementation}
	'data' 'implementation' 
//	implemented=[aadl2::DataType|ID] DOT name=INAME
//	(=> 'extends' extends=[aadl2::DataImplementation|QCREF])?
//	ownedRealization=Realization DOT name=INAME
//	(ownedExtension=ImplementationExtension)?
	(=> 'subcomponents'
	  ((ownedDataSubcomponent+=DataSubcomponent)
//	((ownedSubcomponent+=Subcomponent )+
	| noSubcomponents?=NONE))?
	(=> 'flows'
	(noFlows?=NONE))?
	(=> 'modes'
	((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+
	| noModes?=NONE))?
	(=> 'properties'
	((ownedPropertyAssociation+=PropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID DOT INAME SEMI
	;


Realization returns aadl2::Realization:
	implemented=[aadl2::SystemType|ID];

Prototype returns aadl2::Prototype:
	(ComponentPrototype | FeatureGroupPrototype | FeaturePrototype)
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	SEMI
;


ComponentPrototype returns aadl2::ComponentPrototype:
	name=ID COLON ( 'refined' 'to')?  // remember and then resolve reference. Or we always have reference when refined to
	category=ComponentCategoryKW 
	(constrainingClassifier=[aadl2::ComponentClassifier|QCREF])?
	( array?=LBRACKET RBRACKET)?
	;

FeatureGroupPrototype returns aadl2::FeatureGroupPrototype:
	name=ID COLON ( 'refined' 'to')? 'feature' 'group'
	(constrainingFeatureGroupType=[aadl2::FeatureGroupType|QCREF])?
	;

FeaturePrototype returns aadl2::FeaturePrototype:
	name=ID COLON ( 'refined' 'to')? 'feature'
		(direction=InOutDirection)?  // only in or out not inout
	//(incoming?='in' | outgoing?='out')?
	(constrainingClassifier=[aadl2::ComponentClassifier|QCREF])?
	;


//ComponentClassifierOrPrototype returns aadl2::ComponentClassifierOrPrototype:
//	ComponentClassifier | ComponentPrototype;


SystemSubcomponent returns aadl2::SystemSubcomponent:
	name=ID COLON 'system'
//	(refined?='refined' 'to')? // if boolean is set then we need to find the subcomponent being 'refined'
//	(classifier=[ComponentClassifierOrPrototype|QCREF] )?
	// Could not disambiguate the following rule
	//([SystemClassifier|QCREF]|prototype=[ComponentPrototype|ID])
	systemClassifier=[aadl2::SystemClassifier|QCREF]
	('in' 'modes' LPARENS ((modeBinding+=ModeRef)+ | allModes?='all') RPARENS)?
	SEMI;

ProcessorSubcomponent returns aadl2::ProcessorSubcomponent:
	name=ID COLON 'processor' 
//	(refined?='refined' 'to')? // if boolean is set then we need to find the subcomponent being 'refined'
	 (processorClassifier=[aadl2::ProcessorClassifier|QCREF])?
	('in' 'modes' LPARENS ((modeBinding+=ModeRef)+ | allModes?='all') RPARENS)?
	SEMI;

DataSubcomponent returns aadl2::DataSubcomponent:
	name=ID COLON 'data' 
//	(refined?='refined' 'to')? // if boolean is set then we need to find the subcomponent being 'refined'
	(dataClassifier=[aadl2::DataClassifier|QCREF] )?
	('in' 'modes' LPARENS ((modeBinding+=ModeRef)+ | allModes?='all') RPARENS)?
	SEMI;




// ******** Features

// need to do refined to: as reference vs. ID for basic
DataPort returns aadl2::DataPort:
	name=ID COLON direction=PortDirection 'data' 'port' (dataClassifier=[aadl2::DataType|QCREF])? 
		// array dimensions TODO
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)? SEMI 
	;

EventDataPort returns aadl2::EventDataPort:
	name=ID COLON direction=PortDirection 'event' 'data' 'port' (dataClassifier=[aadl2::DataType|QCREF])? 
		// array dimensions TODO
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)? SEMI 
	;

EventPort returns aadl2::EventPort:
	name=ID COLON direction=PortDirection 'event' 'port' 
		// array dimensions TODO
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)? SEMI 
	;

FeatureGroup returns aadl2::FeatureGroup:
	name=ID 'feature' 'group' featureGroupType=[aadl2::FeatureGroupType|QCREF] 
		// array dimensions TODO
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)? SEMI 
	;

// AccessCategory not set (is encoded in type)
SubprogramAccess returns aadl2::SubprogramAccess: 
	name=ID COLON kind=AccessDirection // refined to with reference to access feature being refined.
	'subprogram' 'access' (subprogramClassifier=[aadl2::SubprogramClassifier|QCREF])? 
	// array dimensions TODO
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)? SEMI 
;
SubprogramGroupAccess returns aadl2::SubprogramGroupAccess: 
	name=ID COLON kind=AccessDirection // refined to with reference to access feature being refined.
	'subprogram' 'group' 'access' (subprogramGroupClassifier=[aadl2::SubprogramGroupClassifier|QCREF])? 
	// array dimensions TODO
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)? SEMI 
;
BusAccess returns aadl2::BusAccess: 
	name=ID COLON kind=AccessDirection  // refined to with reference to access feature being refined.
	'bus' 'access' (busClassifier=[aadl2::BusClassifier|QCREF])? 
	// array dimensions TODO
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)? SEMI 
;
DataAccess returns aadl2::DataAccess: 
	name=ID COLON kind=AccessDirection // refined to with reference to access feature being refined.
	'data' 'access' (dataClassifier=[aadl2::DataClassifier|QCREF])? 
	// array dimensions TODO
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)? SEMI 
;
AbstractFeature returns aadl2::AbstractFeature:
	// need to set inout if no direction
	name=ID COLON (direction=InOutDirection)? 'feature' (classifier=[aadl2::ComponentType|QCREF])? 
	// array dimensions TODO
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)? SEMI 
	;


PortDirection returns aadl2::DirectionType: 'in' | 'out' |  'in' 'out';
InOutDirection returns aadl2::DirectionType: 'in' | 'out' ;
AccessDirection returns aadl2::AccessType: 'requires' | 'provides';



FeatureGroupType returns aadl2::FeatureGroupType:
	'feature' 'group' name=ID 'end' ID SEMI;

// ********* connections 
PortConnection returns aadl2::PortConnection:
	name=ID COLON kind=ConnectionType (
	sourceContext=[aadl2::Context|ID] DOT)? 
	source=[aadl2::ConnectionEnd|ID]
	('->' | bidirectional?='<->')
	(destinationContext=[aadl2::Context|ID] DOT)? destination=[aadl2::ConnectionEnd] SEMI;


ConnectionType returns aadl2::ConnectionKind: 'access' | 'feature' | 'feature' 'group' | 'parameter' | 'port';


Connection returns aadl2::Connection:
	PortConnection;

// ******** Flows 

enum FlowKind returns aadl2::FlowKind:
	source='source' | path='path' | sink='sink';
	
FlowSource returns aadl2::FlowKind: 'source';
FlowSink returns aadl2::FlowKind: 'sink';
FlowPath returns aadl2::FlowKind: 'path';

FlowSpecification returns aadl2::FlowSpecification:
	FlowSourceSpec | FlowSinkSpec | FlowPathSpec
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	( => 'in' 'modes' LPARENS ((inMode+=[aadl2::Mode|ID])+ ) RPARENS)? //| allModes?='all'
	SEMI
	;

FlowSourceSpec returns aadl2::FlowSpecification:
	name=ID COLON 'flow' kind=FlowSource 
	(outContext=[aadl2::Context|ID] DOT )? outFeature=[aadl2::Feature|ID]
;
FlowSinkSpec returns aadl2::FlowSpecification:
	name=ID COLON 'flow' kind=FlowSink 
	(inContext=[aadl2::Context|ID] DOT )? inFeature=[aadl2::Feature|ID]
;
FlowPathSpec returns aadl2::FlowSpecification:
	name=ID COLON 'flow' kind=FlowPath 
	(inContext=[aadl2::Context|ID] DOT )? inFeature=[aadl2::Feature|ID]
	'->' (outContext=[aadl2::Context|ID] DOT )? outFeature=[aadl2::Feature|ID] 
;

// Modes 

Mode returns aadl2::Mode:
	name=ID COLON initial?='initial'? 'mode' SEMI;

ModeTransition returns aadl2::ModeTransition:
	(name=ID COLON)?
	source=[aadl2::Mode|ID] LTRANS
	ownedTrigger+=TriggerPort
	(COMMA ownedTrigger+=TriggerPort)*
	RTRANS destination=[aadl2::Mode|ID] SEMI;

TriggerPort returns aadl2::TriggerPort:
	port=[aadl2::Port|ID];

// NEED to add access features
// used where component_in_modes is shown in standard grammar
ModeRef returns aadl2::ModeBinding:
	parentMode=[aadl2::Mode|ID] ('->' derivedMode=[aadl2::Mode|ID])?;


AnnexLibrary returns aadl2::AnnexLibrary:
	 DefaultAnnexLibrary;

DefaultAnnexLibrary returns aadl2::DefaultAnnexLibrary:
	'annex' name=ID
	sourceText=ANNEXTEXT
	SEMI;


AnnexSubclause returns aadl2::AnnexSubclause:
	 DefaultAnnexSubclause;

DefaultAnnexSubclause returns aadl2::DefaultAnnexSubclause:
	'annex' name=ID
	sourceText=ANNEXTEXT
	SEMI;


terminal EM:
	'error_model';



terminal ANNEXTEXT:
	'{**'->'**}';
	// **************
// Properties

PropertyAssociation returns aadl2::PropertyAssociation :
	property=[aadl2::Property|ID] ASSIGN SEMI;//ownedValue=PropertyExpression 
//
//PropertyExpression:
//	Literal | ProbabilityValue;
//
//Literal:
//	name=ID;
//
//ProbabilityValue:
//	number=REAL distribution=ID;

terminal NONE:
	'none' SEMI;

terminal LTRANS:
	'-[';

terminal RTRANS:
	']->';

terminal SL_COMMENT:
	'--' !('\n' | '\r')* ('\r'? '\n')?;

terminal SEMI:
	';';

terminal COLON:
	':';

terminal COMMA:
	',';

terminal DOT:
	'.';

terminal LPARENS:
	'(';

terminal RPARENS:
	')';

terminal LBRACKET:
	'[';

terminal RBRACKET:
	']';

terminal LCURLY:
	'{';

terminal RCURLY:
	'}';

terminal ASSIGN:
	'=>';

terminal APPEND:
	'+=>';

REAL:
	INT DOT INT;

QNAME:
	ID DOT INAME;

PNAME:
	ID ('::' ID)*;

QPREF:
	ID ('::' ID)?;

INAME:
	ID;

QCREF:
	(ID '::')* ID (DOT ID)?;
	
