grammar org.osate.xtext.aadl2.Aadl2 with //org.osate.xtext.aadl2.properties.Properties
org.eclipse.xtext.common.Terminals
//generate aadl2 "http://www.osate.org/aadl2/Aadl2"

import "platform:/resource/org.osate.aadl2/model/aadl2.ecore" as aadl2

// TODO:   
//InternalEvent(SELF), ProcessorPort: objects in mode transition instead of reference to unnamed owned in impl.

AadlPackage returns aadl2::AadlPackage:
	'package' name=PNAME
	((ownedPublicSection=PublicPackageSection
	(ownedPrivateSection=PrivatePackageSection)?) |
	ownedPrivateSection=PrivatePackageSection)
	(=> 'properties'
	((ownedPropertyAssociation+=PropertyAssociation)+ ))? //| noProperties?=NONE
	'end' ID ('::' ID)* SEMI;


PublicPackageSection returns aadl2::PublicPackageSection:
	{aadl2::PublicPackageSection}
	'public'
	((=> 'with' (importedPackage+=[aadl2::AadlPackage|PNAME]) //| importedPropertySet+=[props::PropertySet|ID]) 
	    (COMMA importedPackage+=[aadl2::AadlPackage|PNAME])* SEMI)
	 | ownedPackageRename+=PackageRename | ownedPackageRename+=PackageRenameAll 
	 | ownedFeatureGroupTypeRename+=FGTRename | ownedComponentTypeRename+=CTRename
	)*
	
	( ownedSystemType+=SystemType| ownedSystemImplementation+=SystemImplementation| ownedProcessorType+=ProcessorType|
	    ownedDataType+=DataType )*;
	// currently derived: (ownedClassifier+=Classifier | ownedAnnexLibrary+=AnnexLibrary)*;


PrivatePackageSection returns aadl2::PrivatePackageSection:
	{aadl2::PrivatePackageSection}
	'private'
	((=> 'with' (importedPackage+=[aadl2::AadlPackage|PNAME]) //| importedPropertySet+=[props::PropertySet|ID]) 
	    (COMMA importedPackage+=[aadl2::AadlPackage|PNAME])* SEMI)
	 | ownedPackageRename+=PackageRename | ownedPackageRename+=PackageRenameAll 
	 | ownedFeatureGroupTypeRename+=FGTRename | ownedComponentTypeRename+=CTRename
	)*

   ( ownedSystemType+=SystemType| ownedSystemImplementation+=SystemImplementation| ownedProcessorType+=ProcessorType|
    ownedDataType+=DataType )*
//	(ownedClassifier+=Classifier | ownedAnnexLibrary+=AnnexLibrary)*
	;
	
PackageRename returns aadl2::PackageRename:
	name=ID 'renames' 'package' renamedPackage=[aadl2::AadlPackage|PNAME]
	SEMI
;
	
PackageRenameAll returns aadl2::PackageRename:
	'renames' 'package' renamedPackage=[aadl2::AadlPackage|PNAME] '::' renameAll?='all' SEMI
	SEMI
;

	
FGTRename returns aadl2::FeatureGroupTypeRename:
	(name=ID)? 'renames' 'feature' 'group' renamedFeatureGroupType=[aadl2::FeatureGroupType|QCREF]
	SEMI
;

	
CTRename returns aadl2::ComponentTypeRename:
	(name=ID)? 'renames' category=ComponentCategory renamedComponentType=[aadl2::ComponentType|QCREF]
	SEMI
;




TypeExtension returns aadl2::TypeExtension:
	'extends' extended=[aadl2::ComponentType|QCREF];

ImplementationExtension returns aadl2::ImplementationExtension:
	'extends' extended=[aadl2::ComponentImplementation|QCREF];

GroupExtension returns aadl2::GroupExtension:
	'extends' extended=[aadl2::FeatureGroupType|QCREF];



ComponentCategory returns aadl2::ComponentCategory: 'abstract' | 'bus'|'data'
	| 'device' | 'memory' | 'process' | 'processor'
	| 'subprogram' 'group' | 'system' | 'thread' 'group'
	| 'thread' | 'virtual' 'bus' | 'virtual' 'processor';


SystemType returns aadl2::SystemType:
	'system' name=ID
	(ownedExtension=TypeExtension
	  (=> LPARENS ownedPrototypeBinding+=PrototypeBinding (COMMA  ownedPrototypeBinding+=PrototypeBinding)* RPARENS)?
	)?
	(=> 'prototypes' (noPrototypes?=NONE |
	(ownedPrototype+=Prototype)+))?
	(=> 'features' (noFeatures?=NONE |
	(ownedDataPort+=DataPort| ownedEventPort+=EventPort | ownedEventDataPort+=EventDataPort)+ ) )?
	(=> 'flows'
	((ownedFlowSpecification+=FlowSpecification)+ | noFlows?=NONE))?
//	(=> requiresModes?='requires' 'modes'
//	((ownedMode+=Mode)+))?
	(=> 'modes' ((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+) | noModes?=NONE)?
	(=> 'properties'
	((ownedPropertyAssociation+=ContainedPropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID SEMI
	;


ProcessType returns aadl2::ProcessType:
	'process' name=ID
	(ownedExtension=TypeExtension
	  (=> LPARENS ownedPrototypeBinding+=PrototypeBinding (COMMA  ownedPrototypeBinding+=PrototypeBinding)* RPARENS)?
	)?
	(=> 'prototypes' (noPrototypes?=NONE |
	(ownedPrototype+=Prototype)+))?
	(=> 'features' (noFeatures?=NONE |
	(ownedDataPort+=DataPort| ownedEventPort+=EventPort | ownedEventDataPort+=EventDataPort)+ ) )?
	(=> 'flows'
	((ownedFlowSpecification+=FlowSpecification)+ | noFlows?=NONE))?
//	(=> requiresModes?='requires' 'modes'
//	((ownedMode+=Mode)+))?
	(=> 'modes' ((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+) | noModes?=NONE)?
	(=> 'properties'
	((ownedPropertyAssociation+=ContainedPropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID SEMI
	;


ThreadType returns aadl2::ThreadType:
	'thread' name=ID
	(ownedExtension=TypeExtension
	  (=> LPARENS ownedPrototypeBinding+=PrototypeBinding (COMMA  ownedPrototypeBinding+=PrototypeBinding)* RPARENS)?
	)?
	(=> 'prototypes' (noPrototypes?=NONE |
	(ownedPrototype+=Prototype)+))?
	(=> 'features' (noFeatures?=NONE |
	(ownedDataPort+=DataPort| ownedEventPort+=EventPort | ownedEventDataPort+=EventDataPort)+ ) )?
	(=> 'flows'
	((ownedFlowSpecification+=FlowSpecification)+ | noFlows?=NONE))?
//	(=> requiresModes?='requires' 'modes'
//	((ownedMode+=Mode)+))?
	(=> 'modes' ((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+) | noModes?=NONE)?
	(=> 'properties'
	((ownedPropertyAssociation+=ContainedPropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID SEMI
	;


ProcessorType returns aadl2::ProcessorType:
	'processor' name=ID
	(ownedExtension=TypeExtension
	  (=> LPARENS ownedPrototypeBinding+=PrototypeBinding (COMMA  ownedPrototypeBinding+=PrototypeBinding)* RPARENS)?
	)?
	(=> 'features' (noFeatures?=NONE |
	(ownedDataPort+=DataPort| ownedEventPort+=EventPort | ownedEventDataPort+=EventDataPort)+ ) )?
	(=> 'flows'
	((ownedFlowSpecification+=FlowSpecification)+ | noFlows?=NONE))?
//	(=> requiresModes?='requires' 'modes'
//	((ownedMode+=Mode)+))?
	(=> 'modes' ((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+) | noModes?=NONE)?
	(=> 'properties'
	((ownedPropertyAssociation+=ContainedPropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID SEMI
	;


DataType returns aadl2::DataType:
	'data' name=ID
	(ownedExtension=TypeExtension
	  (=> LPARENS ownedPrototypeBinding+=PrototypeBinding (COMMA  ownedPrototypeBinding+=PrototypeBinding)* RPARENS)?
	)?
	(=> 'features' noFeatures?=NONE 
//	| (ownedDataPort+=DataPort| ownedEventPort+=EventPort | ownedEventDataPort+=EventDataPort)+ )
	 )?
	(=> 'flows'
	((ownedFlowSpecification+=FlowSpecification)+ | noFlows?=NONE))?
//	(=> requiresModes?='requires' 'modes'
//	((ownedMode+=Mode)+))?
	(=> 'modes' ((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+) | noModes?=NONE)?
	(=> 'properties'
	((ownedPropertyAssociation+=ContainedPropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID SEMI
	;

// Component Implementations: add calls for threads and subprograms



Realization returns aadl2::Realization:
	implemented=[aadl2::SystemType|ID];

SystemImplementation returns aadl2::SystemImplementation:
	{aadl2::SystemImplementation}
	'system' 'implementation' 
	ownedRealization=Realization DOT name=INAME
	(ownedExtension=ImplementationExtension
	  (=> LPARENS ownedPrototypeBinding+=PrototypeBinding (COMMA  ownedPrototypeBinding+=PrototypeBinding)* RPARENS)?
	)?
	(=> 'subcomponents'
	  ((ownedSystemSubcomponent+=SystemSubcomponent
	  |ownedProcessorSubcomponent+=ProcessorSubcomponent
	  |ownedDataSubcomponent+=DataSubcomponent)+
	| noSubcomponents?=NONE)
	)?
// for threadss and subprograms ONLY
//	(=> 'calls'
//	((ownedSubprogamCallSequence+=SubprogramCallSequence)+
//	| noSequences?=NONE))?
	(=> 'connections'
	((ownedPortConnection+=PortConnection)+
	| noConnections?=NONE))?
	(=> 'flows'
	(noFlows?=NONE))?
	(=> 'modes'
	((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+
	| noModes?=NONE))?
	(=> 'properties'
	((ownedPropertyAssociation+=ContainedPropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID DOT INAME SEMI
	;

DataImplementation returns aadl2::DataImplementation:
	{aadl2::DataImplementation}
	'data' 'implementation' 
	ownedRealization=Realization DOT name=INAME
	(ownedExtension=ImplementationExtension
	  (=> LPARENS ownedPrototypeBinding+=PrototypeBinding (COMMA  ownedPrototypeBinding+=PrototypeBinding)* RPARENS)?
	)?
	(=> 'subcomponents'
	  ((ownedDataSubcomponent+=DataSubcomponent)
	| noSubcomponents?=NONE))?
	(=> 'flows'
	(noFlows?=NONE))?
	(=> 'modes'
	((ownedMode+=Mode | ownedModeTransition+=ModeTransition)+
	| noModes?=NONE))?
	(=> 'properties'
	((ownedPropertyAssociation+=ContainedPropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID DOT INAME SEMI
	;

/* subprogram calls */

SubprogramCallSequence returns aadl2::SubprogramCallSequence:
	name = ID LCURLY
	( ownedCallSpecification+=CallSpecification)+
	RCURLY
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	( => 'in' 'modes' LPARENS ((inMode+=[aadl2::Mode|ID])+ ) RPARENS)? //| allModes?='all'
	SEMI
;


CallSpecification returns aadl2::CallSpecification:
	(({aadl2::ProcessorCall}name=ID 'subprogram' 'processor' DOT subprogramAccessName=ID ) | 
     ({aadl2::SubprogramCall}name=ID 'subprogram'(context=[aadl2::CallContext] DOT)? calledSubprogram=[aadl2::CalledSubprogram|ID]))
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	SEMI
;



//******* Prototypes

Prototype returns aadl2::Prototype:
	(ComponentPrototype | FeatureGroupPrototype | FeaturePrototype)
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	SEMI
;


ComponentPrototype returns aadl2::ComponentPrototype:
	((name=ID COLON )|
	(refined=[aadl2::ComponentPrototype|ID] COLON 'refined' 'to'))
	category=ComponentCategory 
	(constrainingClassifier=[aadl2::ComponentClassifier|QCREF])?
	( array?=LBRACKET RBRACKET)?
	;

FeatureGroupPrototype returns aadl2::FeatureGroupPrototype:
	((name=ID COLON )|
	(refined=[aadl2::FeatureGroupPrototype|ID] COLON 'refined' 'to'))
	'feature' 'group'
	(constrainingFeatureGroupType=[aadl2::FeatureGroupType|QCREF])?
	;

FeaturePrototype returns aadl2::FeaturePrototype:
	((name=ID COLON )|
	(refined=[aadl2::FeaturePrototype|ID] COLON 'refined' 'to'))
	'feature'
		(direction=InOutDirection)?  // only in or out not inout
	(constrainingClassifier=[aadl2::ComponentClassifier|QCREF])?
	;

/*
 * Prototype Bindings
 */

PrototypeBinding returns aadl2::PrototypeBinding:
	FeatureGroupPrototypeBinding | FeaturePrototypeBinding | ComponentPrototypeBinding
	;


FeatureGroupPrototypeBinding returns aadl2::FeatureGroupPrototypeBinding:
	formal=[aadl2::Prototype|ID] ASSIGN  'feature' 'group' 
	actual=FeatureGroupTypeReference
	;
	
FeatureGroupTypeReference returns aadl2::FeatureGroupReference:
	featureGroupType=[aadl2::FeatureGroupType|QCREF]
	;

FeaturePrototypeBinding returns aadl2::FeaturePrototypeBinding:
	formal=[aadl2::Prototype|ID] ASSIGN  'feature'  
	actual=(PortSpecification|AccessSpecification|FeaturePrototypeReference)
	;
	
PortSpecification returns aadl2::PortSpecification:
	direction=PortDirection category=PortCategory 'port' classifier=[aadl2::ComponentClassifier|QCREF]
	;
	
AccessSpecification returns aadl2::AccessSpecification:
	kind=AccessDirection category=AccessCategory 'access' classifier=[aadl2::ComponentClassifier|QCREF]
	;

	
FeaturePrototypeReference returns aadl2::FeaturePrototypeReference:
	direction=InOutDirection 'feature' prototype=[aadl2::FeaturePrototype|ID]
	;


ComponentPrototypeBinding returns aadl2::ComponentPrototypeBinding:
	formal=[aadl2::Prototype|ID] ASSIGN  'feature'  
	(actual+=ComponentReference |
	LPARENS actual+=ComponentReference (COMMA actual+=ComponentReference)* RPARENS
	)
	;
ComponentReference returns aadl2::ComponentReference:
	 category=ComponentCategory (LPARENS binding+=PrototypeBinding (COMMA binding+=PrototypeBinding)*RPARENS)?
	;


/*
 * Subcomponents
 */

SystemSubcomponent returns aadl2::SystemSubcomponent:
	((name=ID COLON )|
	(refined=[aadl2::SystemSubcomponent|ID] COLON 'refined' 'to'))
	'system'
//	(classifier=[ComponentClassifierOrPrototype|QCREF] )?
	(systemClassifier=[aadl2::SystemClassifier|QCREF] 
	  (=> LPARENS ownedPrototypeBinding+=PrototypeBinding (COMMA  ownedPrototypeBinding+=PrototypeBinding)* RPARENS)?
	 )?
	 ( arraySpecification=ArraySpecification 
	  ( LBRACKET implementationReference+=ComponentImplementationReference  
	  (COMMA implementationReference+=ComponentImplementationReference)*
	  RBRACKET )? 
	 )?
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?  
	(=> 'in' 'modes' LPARENS ((modeBinding+=ModeRef)+ | allModes?='all') RPARENS)?
	SEMI;

ProcessorSubcomponent returns aadl2::ProcessorSubcomponent:
	((name=ID COLON )|
	(refined=[aadl2::ProcessorSubcomponent|ID] COLON 'refined' 'to'))
	'processor' 
	 (processorClassifier=[aadl2::ProcessorClassifier|QCREF]
	 	(=> LPARENS ownedPrototypeBinding+=PrototypeBinding (COMMA  ownedPrototypeBinding+=PrototypeBinding)* RPARENS)?
	 )?
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?  
	( => 'in' 'modes' LPARENS ((modeBinding+=ModeRef)+ | allModes?='all') RPARENS)?
	SEMI;

DataSubcomponent returns aadl2::DataSubcomponent:
	((name=ID COLON )|
	(refined=[aadl2::DataSubcomponent|ID] COLON 'refined' 'to'))
	'data' 
	(dataClassifier=[aadl2::DataClassifier|QCREF] 
	 (=> LPARENS ownedPrototypeBinding+=PrototypeBinding (COMMA  ownedPrototypeBinding+=PrototypeBinding)* RPARENS)?
	)?
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?  
	(=> 'in' 'modes' LPARENS ((modeBinding+=ModeRef)+ | allModes?='all') RPARENS)?
	SEMI;

ArraySpecification returns aadl2::ArraySpecification:
	// dimension is the same as the size of a list recording LBRACKET or size if we put a dummy object
	{aadl2::ArraySpecification}(LBRACKET (size+=Numeral | size+=PropertyReference)? RBRACKET)+
;

SingleArraySpecification returns aadl2::ArraySpecification:
	// dimension is the same as the size of a list recording LBRACKET or size if we put a dummy object
	{aadl2::ArraySpecification}LBRACKET (size+=Numeral | size+=PropertyReference)? RBRACKET
;


Numeral returns aadl2::Numeral:
	value=gINT 
;

ComponentImplementationReference returns aadl2::ComponentImplementationReference:
	implementation=[aadl2::ComponentImplementation|QCREF] 
;

PropertyReference returns aadl2::PropertyReference:
	property=[aadl2::Property|QPREF] 
	// reference also could be to a property constant, which is recorded as reference in a
	// ConstantValue object 
	
;


// ******** Features

// needs to have classifier or prototype reference
DataPort returns aadl2::DataPort:
	((name=ID COLON )|
	(refined=[aadl2::DataPort|ID] COLON 'refined' 'to'))
	direction=PortDirection 'data' 'port' (dataClassifier=[aadl2::DataType|QCREF])? 
	(arraySpecification=SingleArraySpecification)?
	(=> LCURLY (ownedPropertyAssociation+=ContainedPropertyAssociation)+ RCURLY)? SEMI 
	;

EventDataPort returns aadl2::EventDataPort:
	((name=ID COLON )|
	(refined=[aadl2::EventDataPort|ID] COLON 'refined' 'to'))
	direction=PortDirection 'event' 'data' 'port' (dataClassifier=[aadl2::DataType|QCREF])? 
	(arraySpecification=SingleArraySpecification)?
	(=> LCURLY (ownedPropertyAssociation+=ContainedPropertyAssociation)+ RCURLY)? SEMI 
	;

EventPort returns aadl2::EventPort:
	((name=ID COLON )|
	(refined=[aadl2::EventPort|ID] COLON 'refined' 'to'))
	direction=PortDirection 'event' 'port' 
	(arraySpecification=SingleArraySpecification)?
	(=> LCURLY (ownedPropertyAssociation+=ContainedPropertyAssociation)+ RCURLY)? SEMI 
	;

FeatureGroup returns aadl2::FeatureGroup:
		// need to set inout if no direction
	((name=ID COLON )|
	(refined=[aadl2::FeatureGroup|ID] COLON 'refined' 'to'))
	direction=InOutDirection 'feature' 'group' 
	( inverse?='inverse' 'of')?
	featureGroupType=[aadl2::FeatureGroupType|QCREF] // or prototype
	(arraySpecification=SingleArraySpecification)?
	(=> LCURLY (ownedPropertyAssociation+=ContainedPropertyAssociation)+ RCURLY)? SEMI 
	;

Parameter returns aadl2::Parameter:
	((name=ID COLON )|
	(refined=[aadl2::Parameter|ID] COLON 'refined' 'to'))
	direction=PortDirection 'parameter' (dataClassifier=[aadl2::DataType|QCREF])? 
	(arraySpecification=SingleArraySpecification)?
	(=> LCURLY (ownedPropertyAssociation+=ContainedPropertyAssociation)+ RCURLY)? SEMI 
	;

// AccessCategory not set (is encoded in type)
SubprogramAccess returns aadl2::SubprogramAccess: 
	((name=ID COLON )|
	(refined=[aadl2::SubprogramAccess|ID] COLON 'refined' 'to'))
	kind=AccessDirection // refined to with reference to access feature being refined.
	'subprogram' 'access' (subprogramClassifier=[aadl2::SubprogramClassifier|QCREF])? 
	(arraySpecification=SingleArraySpecification)?
	(=> LCURLY (ownedPropertyAssociation+=ContainedPropertyAssociation)+ RCURLY)? SEMI 
;
SubprogramGroupAccess returns aadl2::SubprogramGroupAccess: 
	((name=ID COLON )|
	(refined=[aadl2::SubprogramGroupAccess|ID] COLON 'refined' 'to'))
	kind=AccessDirection // refined to with reference to access feature being refined.
	'subprogram' 'group' 'access' (subprogramGroupClassifier=[aadl2::SubprogramGroupClassifier|QCREF])? 
	(arraySpecification=SingleArraySpecification)?
	(=> LCURLY (ownedPropertyAssociation+=ContainedPropertyAssociation)+ RCURLY)? SEMI 
;
BusAccess returns aadl2::BusAccess: 
	((name=ID COLON )|
	(refined=[aadl2::BusAccess|ID] COLON 'refined' 'to'))
	kind=AccessDirection  // refined to with reference to access feature being refined.
	'bus' 'access' (busClassifier=[aadl2::BusClassifier|QCREF])? 
	(arraySpecification=SingleArraySpecification)?
	(=> LCURLY (ownedPropertyAssociation+=ContainedPropertyAssociation)+ RCURLY)? SEMI 
;
DataAccess returns aadl2::DataAccess: 
	((name=ID COLON )|
	(refined=[aadl2::DataAccess|ID] COLON 'refined' 'to'))
	kind=AccessDirection // refined to with reference to access feature being refined.
	'data' 'access' (dataClassifier=[aadl2::DataClassifier|QCREF])? 
	(arraySpecification=SingleArraySpecification)?
	(=> LCURLY (ownedPropertyAssociation+=ContainedPropertyAssociation)+ RCURLY)? SEMI 
;
AbstractFeature returns aadl2::AbstractFeature:
	// need to set inout if no direction
	((name=ID COLON )|
	(refined=[aadl2::AbstractFeature|ID] COLON 'refined' 'to'))
	(direction=InOutDirection)? 'feature' (classifier=[aadl2::ComponentType|QCREF])? 
	(arraySpecification=SingleArraySpecification)?
	(=> LCURLY (ownedPropertyAssociation+=ContainedPropertyAssociation)+ RCURLY)? SEMI 
	;


PortDirection returns aadl2::DirectionType: 'in' | 'out' |  'in' 'out';
InOutDirection returns aadl2::DirectionType: 'in' | 'out' ;
AccessDirection returns aadl2::AccessType: 'requires' | 'provides';

PortCategory returns aadl2::PortCategory: 'data' | 'event' |  'event' 'data';


FeatureGroupType returns aadl2::FeatureGroupType:
	'feature' 'group' name=ID 
	(ownedExtension=GroupExtension
	  (=> LPARENS ownedPrototypeBinding+=PrototypeBinding (COMMA  ownedPrototypeBinding+=PrototypeBinding)* RPARENS)?
	)?
	(=> 'prototypes' (noPrototypes?=NONE |
	(ownedPrototype+=Prototype)+))?
	(=> 'features' (// no none for FGT noFeatures?=NONE |
	(ownedDataPort+=DataPort| ownedEventPort+=EventPort | ownedEventDataPort+=EventDataPort)+ ) )?
	(=> 'inverse' 'of' inverse=[aadl2::FeatureGroupType|QCREF])?
	(=> 'properties'
	((ownedPropertyAssociation+=ContainedPropertyAssociation)+
	| noProperties?=NONE))?
	(ownedAnnexSubclause+=AnnexSubclause)*
	'end' ID SEMI;

// ********* connections 

PortConnection returns aadl2::PortConnection:
	((name=ID COLON )|
	(refined=[aadl2::PortConnection|ID] COLON 'refined' 'to'))
	kind=PortConnectionKind 
	( // 'processor' and 'self' for both source and destination
	sourceContext=[aadl2::Context|ID] DOT)? 
	source=[aadl2::ConnectionEnd|ID]
	(ARROW | bidirectional?='<->')
	(destinationContext=[aadl2::Context|ID] DOT)? destination=[aadl2::ConnectionEnd] 
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	( => 'in' 'modes' LPARENS ((inMode+=[aadl2::Mode|ID])+ ) RPARENS)? //| allModes?='all'
	// also needs to refer to transitions
	SEMI;

AccessConnection returns aadl2::AccessConnection:
	((name=ID COLON )|
	(refined=[aadl2::AccessConnection|ID] COLON 'refined' 'to'))
	accessCategory=AccessCategory kind=AccessConnectionKind 
	(// 'processor' => ProcessorSubprogram as source 
	(sourceContext=[aadl2::Context|ID] DOT)? 
	source=[aadl2::ConnectionEnd|ID])
	(ARROW | bidirectional?='<->')
	(destinationContext=[aadl2::Context|ID] DOT)? destination=[aadl2::ConnectionEnd] 
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	( => 'in' 'modes' LPARENS ((inMode+=[aadl2::Mode|ID])+ ) RPARENS)? //| allModes?='all'
	SEMI;

FeatureGroupConnection returns aadl2::FeatureGroupConnection:
	((name=ID COLON )|
	(refined=[aadl2::FeatureGroupConnection|ID] COLON 'refined' 'to'))
	kind=FeatureGroupConnectionKind 
	( // only regular cotnexts, no processor or self 
	(sourceContext=[aadl2::Context|ID] DOT)? 
	source=[aadl2::ConnectionEnd|ID])
	( bidirectional?='<->')
	(destinationContext=[aadl2::Context|ID] DOT)? destination=[aadl2::ConnectionEnd] 
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	( => 'in' 'modes' LPARENS ((inMode+=[aadl2::Mode|ID])+ ) RPARENS)? //| allModes?='all'
	SEMI;

FeatureConnection returns aadl2::FeatureConnection:
	((name=ID COLON )|
	(refined=[aadl2::FeatureConnection|ID] COLON 'refined' 'to'))
	kind=FeatureConnectionKind 
	( // only regular cotnexts, no processor or self 
	(sourceContext=[aadl2::Context|ID] DOT)? 
	source=[aadl2::ConnectionEnd|ID])
	(ARROW | bidirectional?='<->')
	(destinationContext=[aadl2::Context|ID] DOT)? destination=[aadl2::ConnectionEnd] 
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	( => 'in' 'modes' LPARENS ((inMode+=[aadl2::Mode|ID])+ ) RPARENS)? //| allModes?='all'
	SEMI;

ParameterConnection returns aadl2::ParameterConnection:
	((name=ID COLON )|
	(refined=[aadl2::ParameterConnection|ID] COLON 'refined' 'to'))
	kind=ParameterConnectionKind 
	( // only regular cotnexts, no processor or self 
	(sourceContext=[aadl2::Context|ID] DOT)? 
	source=[aadl2::ConnectionEnd|ID])
	 ARROW
	(destinationContext=[aadl2::Context|ID] DOT)? destination=[aadl2::ConnectionEnd] 
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	( => 'in' 'modes' LPARENS ((inMode+=[aadl2::Mode|ID])+ ) RPARENS)? //| allModes?='all'
	SEMI;



ConnectionKind returns aadl2::ConnectionKind: 'access' | 'feature' | 'feature' 'group' | 'parameter' | 'port';
PortConnectionKind returns aadl2::ConnectionKind: 'port';
AccessConnectionKind returns aadl2::ConnectionKind: 'access';
FeatureGroupConnectionKind returns aadl2::ConnectionKind: 'feature' 'group';
FeatureConnectionKind returns aadl2::ConnectionKind: 'feature';
ParameterConnectionKind returns aadl2::ConnectionKind: 'parameter';

AccessCategory returns aadl2::AccessCategory:
	'bus' | 'data' | 'subprogram' | 'subprogram' 'group';

Connection returns aadl2::Connection:
	PortConnection;

// ******** Flows 

enum FlowKind returns aadl2::FlowKind:
	source='source' | path='path' | sink='sink';
	
FlowSource returns aadl2::FlowKind: 'source';
FlowSink returns aadl2::FlowKind: 'sink';
FlowPath returns aadl2::FlowKind: 'path';

FlowSpecification returns aadl2::FlowSpecification:
	( FlowSourceSpec | FlowSinkSpec | FlowPathSpec
	|FlowSourceSpecRefinement | FlowSinkSpecRefinement | FlowPathSpecRefinement )
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	( => 'in' 'modes' LPARENS ((inMode+=[aadl2::Mode|ID])+ ) RPARENS)? //| allModes?='all'
	SEMI
	;

FlowSourceSpec returns aadl2::FlowSpecification:
	name=ID COLON 
	'flow' kind=FlowSource 
	(outContext=[aadl2::Context|ID] DOT )? outFeature=[aadl2::Feature|ID]
;
FlowSinkSpec returns aadl2::FlowSpecification:
	name=ID COLON 
	'flow' kind=FlowSink 
	(inContext=[aadl2::Context|ID] DOT )? inFeature=[aadl2::Feature|ID]
;
FlowPathSpec returns aadl2::FlowSpecification:
	name=ID COLON 
	'flow' kind=FlowPath 
	(inContext=[aadl2::Context|ID] DOT )? inFeature=[aadl2::Feature|ID]
	ARROW (outContext=[aadl2::Context|ID] DOT )? outFeature=[aadl2::Feature|ID] 
;
FlowSourceSpecRefinement returns aadl2::FlowSpecification:
	refined=[aadl2::FlowSpecification|ID] COLON 'refined' 'to' 'flow' kind=FlowSource 
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
;
FlowSinkSpecRefinement returns aadl2::FlowSpecification:
	refined=[aadl2::FlowSpecification|ID] COLON 'refined' 'to' 'flow' kind=FlowSink 
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
;
FlowPathSpecRefinement returns aadl2::FlowSpecification:
	refined=[aadl2::FlowSpecification|ID] COLON 'refined' 'to' 'flow' kind=FlowPath 
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
;

FlowImplementation returns aadl2::FlowImplementation:
	( FlowSourceImpl | FlowSinkImpl | FlowPathImpl )
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	( => 'in' 'modes' LPARENS ((inMode+=[aadl2::Mode|ID])+ ) RPARENS)? //| allModes?='all'
	SEMI
;

FlowSourceImpl returns aadl2::FlowImplementation:
	specification=[aadl2::FlowSpecification|ID]//name=ID 
	COLON 'flow' kind=FlowSource 
    (  ownedSubcomponentFlow+=SubcomponentFlow ARROW flowElement+=[aadl2::Connection|ID] ARROW )*
//	(outContext=[aadl2::Context|ID] DOT )? outFeature=[aadl2::Feature|ID]
;
FlowSinkImpl returns aadl2::FlowImplementation:
	specification=[aadl2::FlowSpecification|ID]//name=ID 
	COLON 'flow' kind=FlowSink 
//	(inContext=[aadl2::Context|ID] DOT )? inFeature=[aadl2::Feature|ID]
    ( ARROW flowElement+=[aadl2::Connection|ID] ARROW ownedSubcomponentFlow+=SubcomponentFlow  )*
;
FlowPathImpl returns aadl2::FlowImplementation:
	specification=[aadl2::FlowSpecification|ID]//name=ID 
	COLON 'flow' kind=FlowPath 
//	(inContext=[aadl2::Context|ID] DOT )? inFeature=[aadl2::Feature|ID]
	(  ( ARROW flowElement+=[aadl2::Connection|ID] ARROW ownedSubcomponentFlow+=SubcomponentFlow   )*
	    ARROW flowElement+=[aadl2::Connection|ID] )?
//	ARROW (outContext=[aadl2::Context|ID] DOT )? outFeature=[aadl2::Feature|ID] 
;


EndToEndFlow returns aadl2::EndToEndFlow: 
    name=ID COLON 'end' 'to' 'end' 'flow'
    ownedSubcomponentFlow+=SubcomponentFlow
    ( ARROW flowElement+=[aadl2::Connection|ID] ARROW ownedSubcomponentFlow+=SubcomponentFlow )*
    
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	( => 'in' 'modes' LPARENS ((inMode+=[aadl2::Mode|ID])+ ) RPARENS)? //| allModes?='all'
    SEMI
    ;
    
EndToEndFlowRefinement returns aadl2::EndToEndFlow:
	refined=[aadl2::EndToEndFlow|ID] COLON 'refined' 'to' 'end' 'to' 'end' 'flow'  
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	( => 'in' 'modes' LPARENS ((inMode+=[aadl2::Mode|ID])+ ) RPARENS)? //| allModes?='all'
;

SubcomponentFlow returns aadl2::SubcomponentFlow:
	context=[aadl2::Subcomponent|ID] DOT flowSpecification=[aadl2::FlowSpecification|ID]
	// could refer to data access which is stored as dataAccess instead of flowSpec
	// could also refere to endtoend flow
;


// Modes 

Mode returns aadl2::Mode:
	name=ID COLON initial?='initial'? 'mode' 
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	SEMI;

ModeTransition returns aadl2::ModeTransition:
	(name=ID COLON)?
	source=[aadl2::Mode|ID] LTRANS
	ownedTrigger+=TriggerPort
	(COMMA ownedTrigger+=TriggerPort)*
	RTRANS destination=[aadl2::Mode|ID] 
	(=> LCURLY (ownedPropertyAssociation+=PropertyAssociation)+ RCURLY)?
	SEMI;

TriggerPort returns aadl2::TriggerPort:
	// (self?='self'|processor?='processor') vs. special object reference as context 
	(context=[aadl2::Context|ID] DOT)? port=[aadl2::Port|ID]
	;

// used where component_in_modes is shown in standard grammar
ModeRef returns aadl2::ModeBinding:
	parentMode=[aadl2::Mode|ID] (ARROW derivedMode=[aadl2::Mode|ID])?;


AnnexLibrary returns aadl2::AnnexLibrary:
	 DefaultAnnexLibrary;

DefaultAnnexLibrary returns aadl2::DefaultAnnexLibrary:
	'annex' name=ID
	sourceText=ANNEXTEXT
	SEMI;


AnnexSubclause returns aadl2::AnnexSubclause:
	 DefaultAnnexSubclause;

DefaultAnnexSubclause returns aadl2::DefaultAnnexSubclause:
	'annex' name=ID
	sourceText=ANNEXTEXT
	SEMI;


terminal EM:
	'error_model';



terminal ANNEXTEXT:
	'{**'->'**}';
	// **************
// Properties

PropertyAssociation returns aadl2::PropertyAssociation :
	property=[aadl2::Property|ID] ASSIGN //ownedValue=PropertyExpression 
	SEMI;

ContainedPropertyAssociation returns aadl2::PropertyAssociation :
	property=[aadl2::Property|ID] ASSIGN //ownedValue=PropertyExpression
	(=> 'applies' 'to' appliesTo+=ContainmentPath)?
	SEMI ; 
	
ContainmentPath returns aadl2::ContainedNamedElement:
	{aadl2::ContainedNamedElement}
	containmentPathElement+=ContainmentPathElement
	( COMMA containmentPathElement+=ContainmentPathElement)*
;

ContainmentPathElement returns aadl2::ContainmentPathElement:
	namedElement=[aadl2::NamedElement|ID]
	 arrayRange+=ArrayRange
;

ArrayRange returns aadl2::ArrayRange: {aadl2::ArrayRange}
	LBRACKET //lowerBound=INT ( upperBound=INT)? 
	RBRACKET
;
//
//PropertyExpression:
//	Literal | ProbabilityValue;
//
//Literal:
//	name=ID;
//
//ProbabilityValue:
//	number=REAL distribution=ID;


terminal NONE:
	'none' SEMI;

terminal LTRANS:
	'-[';

terminal RTRANS:
	']->';
	
terminal ARROW: '->';	

terminal SL_COMMENT:
	'--' !('\n' | '\r')* ('\r'? '\n')?;

terminal SEMI:
	';';

terminal COLON:
	':';

terminal COMMA:
	',';

terminal DOT:
	'.';

terminal LPARENS:
	'(';

terminal RPARENS:
	')';

terminal LBRACKET:
	'[';

terminal RBRACKET:
	']';

terminal LCURLY:
	'{';

terminal RCURLY:
	'}';

terminal ASSIGN:
	'=>';

terminal APPEND:
	'+=>';

//INTEGER returns aadl2::Integer:
//	INT ;

gINT returns aadl2::Integer:
	INT 	
;


REAL:
	INT DOT INT;

TINAME:
	ID DOT INAME;

PNAME:
	ID ('::' ID)*;

QPREF:
	ID ('::' ID)?;

INAME:
	ID;

QCREF:
	(ID '::')* ID (DOT ID)?;
	
