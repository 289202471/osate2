
/*
* generated by Xtext
*/
lexer grammar InternalAadl2Lexer;


@header {
package org.osate.xtext.aadl2.parser.antlr.lexer;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}




KEYWORD_52 : 'implementation';

KEYWORD_51 : 'subcomponents';

KEYWORD_50 : 'connections';

KEYWORD_47 : 'properties';

KEYWORD_48 : 'prototypes';

KEYWORD_49 : 'subprogram';

KEYWORD_45 : 'parameter';

KEYWORD_46 : 'processor';

KEYWORD_41 : 'abstract';

KEYWORD_42 : 'features';

KEYWORD_43 : 'provides';

KEYWORD_44 : 'requires';

KEYWORD_30 : 'applies';

KEYWORD_31 : 'extends';

KEYWORD_32 : 'feature';

KEYWORD_33 : 'initial';

KEYWORD_34 : 'inverse';

KEYWORD_35 : 'package';

KEYWORD_36 : 'private';

KEYWORD_37 : 'process';

KEYWORD_38 : 'refined';

KEYWORD_39 : 'renames';

KEYWORD_40 : 'virtual';

KEYWORD_23 : 'access';

KEYWORD_24 : 'device';

KEYWORD_25 : 'memory';

KEYWORD_26 : 'public';

KEYWORD_27 : 'source';

KEYWORD_28 : 'system';

KEYWORD_29 : 'thread';

KEYWORD_17 : 'annex';

KEYWORD_18 : 'calls';

KEYWORD_19 : 'event';

KEYWORD_20 : 'flows';

KEYWORD_21 : 'group';

KEYWORD_22 : 'modes';

KEYWORD_10 : 'data';

KEYWORD_11 : 'flow';

KEYWORD_12 : 'mode';

KEYWORD_13 : 'path';

KEYWORD_14 : 'port';

KEYWORD_15 : 'sink';

KEYWORD_16 : 'with';

KEYWORD_5 : '<->';

KEYWORD_6 : 'all';

KEYWORD_7 : 'bus';

KEYWORD_8 : 'end';

KEYWORD_9 : 'out';

KEYWORD_1 : '::';

KEYWORD_2 : 'in';

KEYWORD_3 : 'of';

KEYWORD_4 : 'to';



RULE_EM : 'error_model';

RULE_ANNEXTEXT : '{**' ( options {greedy=false;} : . )*'**}';

RULE_NONE : 'none' RULE_SEMI;

RULE_LTRANS : '-[';

RULE_RTRANS : ']->';

RULE_ARROW : '->';

RULE_SL_COMMENT : '--' ~(('\n'|'\r'))* ('\r'? '\n')?;

RULE_SEMI : ';';

RULE_COLON : ':';

RULE_COMMA : ',';

RULE_DOTDOT : '..';

RULE_DOT : '.';

RULE_LPARENS : '(';

RULE_RPARENS : ')';

RULE_LBRACKET : '[';

RULE_RBRACKET : ']';

RULE_LCURLY : '{';

RULE_RCURLY : '}';

RULE_ASSIGN : '=>';

RULE_APPEND : '+=>';

RULE_ID : '^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

RULE_INT : ('0'..'9')+;

RULE_STRING : ('"' ('\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\''|'\\')|~(('\\'|'"')))* '"'|'\'' ('\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\''|'\\')|~(('\\'|'\'')))* '\'');

RULE_ML_COMMENT : '/*' ( options {greedy=false;} : . )*'*/';

RULE_WS : (' '|'\t'|'\r'|'\n')+;

RULE_ANY_OTHER : .;



