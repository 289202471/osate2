
/*
* generated by Xtext
*/
lexer grammar InternalAadl2Lexer;


@header {
package org.osate.xtext.aadl2.parser.antlr.lexer;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}




KEYWORD_98 : 'implementation';

KEYWORD_97 : 'subcomponents';

KEYWORD_93 : 'aadlboolean';

KEYWORD_94 : 'aadlinteger';

KEYWORD_95 : 'connections';

KEYWORD_96 : 'enumeration';

KEYWORD_88 : 'aadlstring';

KEYWORD_89 : 'classifier';

KEYWORD_90 : 'properties';

KEYWORD_91 : 'prototypes';

KEYWORD_92 : 'subprogram';

KEYWORD_84 : 'parameter';

KEYWORD_85 : 'processor';

KEYWORD_86 : 'prototype';

KEYWORD_87 : 'reference';

KEYWORD_77 : 'aadlreal';

KEYWORD_78 : 'abstract';

KEYWORD_79 : 'constant';

KEYWORD_80 : 'features';

KEYWORD_81 : 'property';

KEYWORD_82 : 'provides';

KEYWORD_83 : 'requires';

KEYWORD_64 : 'applies';

KEYWORD_65 : 'compute';

KEYWORD_66 : 'extends';

KEYWORD_67 : 'feature';

KEYWORD_68 : 'inherit';

KEYWORD_69 : 'initial';

KEYWORD_70 : 'inverse';

KEYWORD_71 : 'package';

KEYWORD_72 : 'private';

KEYWORD_73 : 'process';

KEYWORD_74 : 'refined';

KEYWORD_75 : 'renames';

KEYWORD_76 : 'virtual';

KEYWORD_56 : 'access';

KEYWORD_57 : 'device';

KEYWORD_58 : 'memory';

KEYWORD_59 : 'public';

KEYWORD_60 : 'record';

KEYWORD_61 : 'source';

KEYWORD_62 : 'system';

KEYWORD_63 : 'thread';

KEYWORD_46 : 'annex';

KEYWORD_47 : 'calls';

KEYWORD_48 : 'delta';

KEYWORD_49 : 'event';

KEYWORD_50 : 'false';

KEYWORD_51 : 'flows';

KEYWORD_52 : 'group';

KEYWORD_53 : 'modes';

KEYWORD_54 : 'range';

KEYWORD_55 : 'units';

KEYWORD_34 : 'data';

KEYWORD_35 : 'flow';

KEYWORD_36 : 'list';

KEYWORD_37 : 'mode';

KEYWORD_38 : 'none';

KEYWORD_39 : 'path';

KEYWORD_40 : 'port';

KEYWORD_41 : 'self';

KEYWORD_42 : 'sink';

KEYWORD_43 : 'true';

KEYWORD_44 : 'type';

KEYWORD_45 : 'with';

KEYWORD_24 : '+=>';

KEYWORD_25 : '<->';

KEYWORD_26 : ']->';

KEYWORD_27 : 'all';

KEYWORD_28 : 'and';

KEYWORD_29 : 'bus';

KEYWORD_30 : 'end';

KEYWORD_31 : 'not';

KEYWORD_32 : 'out';

KEYWORD_33 : 'set';

KEYWORD_14 : '->';

KEYWORD_15 : '-[';

KEYWORD_16 : '..';

KEYWORD_17 : '::';

KEYWORD_18 : '=>';

KEYWORD_19 : 'in';

KEYWORD_20 : 'is';

KEYWORD_21 : 'of';

KEYWORD_22 : 'or';

KEYWORD_23 : 'to';

KEYWORD_1 : '(';

KEYWORD_2 : ')';

KEYWORD_3 : '*';

KEYWORD_4 : '+';

KEYWORD_5 : ',';

KEYWORD_6 : '-';

KEYWORD_7 : '.';

KEYWORD_8 : ':';

KEYWORD_9 : ';';

KEYWORD_10 : '[';

KEYWORD_11 : ']';

KEYWORD_12 : '{';

KEYWORD_13 : '}';



RULE_ANNEXTEXT : '{**' ( options {greedy=false;} : . )*'**}';

RULE_SL_COMMENT : '--' ~(('\n'|'\r'))* ('\r'? '\n')?;

fragment RULE_EXPONENT : 'e' ('+'|'-')? RULE_DIGIT+;

fragment RULE_INT_EXPONENT : 'e' '+'? RULE_DIGIT+;

RULE_REAL_LIT : RULE_DIGIT+ ('_' RULE_DIGIT+)* '.' RULE_DIGIT+ ('_' RULE_DIGIT+)* RULE_EXPONENT?;

RULE_INTEGER_LIT : RULE_DIGIT+ ('_' RULE_DIGIT+)* ('#' RULE_BASED_INTEGER '#' RULE_INT_EXPONENT?|RULE_INT_EXPONENT?);

fragment RULE_BASE : RULE_DIGIT RULE_DIGIT?;

fragment RULE_DIGIT : '0'..'9';

fragment RULE_EXTENDED_DIGIT : ('0'..'9'|'a'..'f'|'A'..'F');

fragment RULE_BASED_INTEGER : RULE_EXTENDED_DIGIT ('_'? RULE_EXTENDED_DIGIT)*;

RULE_STRING : ('"' ('\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\''|'\\')|~(('\\'|'"')))* '"'|'\'' ('\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\''|'\\')|~(('\\'|'\'')))* '\'');

RULE_ID : '^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

RULE_WS : (' '|'\t'|'\r'|'\n')+;



